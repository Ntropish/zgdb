// Generated by ZG. Do not edit.
import { ZgDatabase, ZgBaseNode, ZgAuthContext } from '@zgdb/client';
import * as LowLevel from './schema.js';
import { Builder, ByteBuffer } from 'flatbuffers';

// This is a hack. The generated schema.ts file exports all root functions,
// but we need a single entry point to look them up dynamically.
const getRootAs = (bb: ByteBuffer, identifier: string) => {
  const funcName = `getRootAs${identifier}`;
  if (funcName in LowLevel) {
    return (LowLevel as any)[funcName](bb);
  }
  throw new Error(`Invalid identifier for getRootAs: ${identifier}`);
}

// --- Helper Types ---
type ResolverFn = (context: any) => any;
type ResolverMap = Record<string, ResolverFn>;
type ResolvedNode<TNode, TEntityResolvers extends ResolverMap, TGlobalResolvers extends ResolverMap> = TNode & {
  [K in keyof TEntityResolvers]: ReturnType<TEntityResolvers[K]>;
} & {
  [K in keyof TGlobalResolvers]: ReturnType<TGlobalResolvers[K]>;
};

// --- Interfaces ---
export interface IUser {
  id: string;
  publicKey: string;
  displayName: string;
  avatarUrl: string;
}

export interface IPost {
  id: string;
  title: string;
  content: string;
  authorId: string;
  createdAt: bigint;
}

export interface IComment {
  id: string;
  content: string;
  authorId: string;
  postId: string;
  createdAt: bigint;
}

export interface IFollow {
  id: string;
  followerId: string;
  followingId: string;
  createdAt: bigint;
}

export interface IImage_Metadata {
  width: bigint;
  height: bigint;
  format: string;
  createdAt: bigint;
}

export interface IImage {
  id: string;
  url: string;
  fartCount: bigint;
  altText: string;
  metadata: any;
  postId: string;
  userId: string;
}

export interface IReaction {
  id: string;
  type: string;
  authorId: string;
  targetId: string;
  targetType: string;
}

export interface ITag {
  id: string;
  name: string;
}

export interface IPostTag {
  id: string;
  postId: string;
  tagId: string;
}

// --- Node Classes ---
export class UserNode<TActor> extends ZgBaseNode<LowLevel.User, TActor> {
  constructor(
    db: ZgDatabase,
    fbb: LowLevel.User,
    authContext: ZgAuthContext<TActor> | null
  ) {
    super(db, fbb, authContext);
    
    return new Proxy(this, {
      set: (target, prop, value, receiver) => {
        const schemaFields = new Set(['id', 'publicKey', 'displayName', 'avatarUrl']);
        if (!schemaFields.has(prop as string)) {
          return Reflect.set(target, prop, value, receiver);
        }

        const builder = new Builder(1024);
        const data = { id: (prop === 'id') ? value : target.fbb.id(), publicKey: (prop === 'publicKey') ? value : target.fbb.publicKey(), displayName: (prop === 'displayName') ? value : target.fbb.displayName(), avatarUrl: (prop === 'avatarUrl') ? value : target.fbb.avatarUrl() };
        
    const idOffset = data.id ? builder.createString(data.id) : 0;
    const publicKeyOffset = data.publicKey ? builder.createString(data.publicKey) : 0;
    const displayNameOffset = data.displayName ? builder.createString(data.displayName) : 0;
    const avatarUrlOffset = data.avatarUrl ? builder.createString(data.avatarUrl) : 0;
        
        const entityOffset = LowLevel.createUser(builder, idOffset, publicKeyOffset, displayNameOffset, avatarUrlOffset);
        builder.finish(entityOffset);
        const buffer = builder.asUint8Array();

        target.db.update(
          'User',
          target.id,
          buffer
        );
        
        const newFbb = getRootAs(new ByteBuffer(buffer), 'User') as LowLevel.User;
        target.fbb = newFbb;

        return true;
      }
    });
  }

  // --- Fields ---
  get id(): string | null {
    return this.fbb.id();
  }

  get publicKey(): string | null {
    return this.fbb.publicKey();
  }

  get displayName(): string | null {
    return this.fbb.displayName();
  }

  get avatarUrl(): string | null {
    return this.fbb.avatarUrl();
  }

  // --- Relationships ---
  get posts(): PostNode<TActor> | null {
    const id = this.fbb.postsId();
    if (!id) return null;
    return this.db.get(
      'Post',
       id,
       (db, fbb, ac) => new PostNode<TActor>(db, fbb, ac),
       (bb) => getRootAs(bb, 'Post') as LowLevel.Post,
       this.authContext
    ) as PostNode<TActor> | null;
  }

  get comments(): CommentNode<TActor> | null {
    const id = this.fbb.commentsId();
    if (!id) return null;
    return this.db.get(
      'Comment',
       id,
       (db, fbb, ac) => new CommentNode<TActor>(db, fbb, ac),
       (bb) => getRootAs(bb, 'Comment') as LowLevel.Comment,
       this.authContext
    ) as CommentNode<TActor> | null;
  }

  get reactions(): ReactionNode<TActor> | null {
    const id = this.fbb.reactionsId();
    if (!id) return null;
    return this.db.get(
      'Reaction',
       id,
       (db, fbb, ac) => new ReactionNode<TActor>(db, fbb, ac),
       (bb) => getRootAs(bb, 'Reaction') as LowLevel.Reaction,
       this.authContext
    ) as ReactionNode<TActor> | null;
  }

  get following(): FollowNode<TActor> | null {
    const id = this.fbb.followingId();
    if (!id) return null;
    return this.db.get(
      'Follow',
       id,
       (db, fbb, ac) => new FollowNode<TActor>(db, fbb, ac),
       (bb) => getRootAs(bb, 'Follow') as LowLevel.Follow,
       this.authContext
    ) as FollowNode<TActor> | null;
  }

  get followers(): FollowNode<TActor> | null {
    const id = this.fbb.followersId();
    if (!id) return null;
    return this.db.get(
      'Follow',
       id,
       (db, fbb, ac) => new FollowNode<TActor>(db, fbb, ac),
       (bb) => getRootAs(bb, 'Follow') as LowLevel.Follow,
       this.authContext
    ) as FollowNode<TActor> | null;
  }
}

export class PostNode<TActor> extends ZgBaseNode<LowLevel.Post, TActor> {
  constructor(
    db: ZgDatabase,
    fbb: LowLevel.Post,
    authContext: ZgAuthContext<TActor> | null
  ) {
    super(db, fbb, authContext);
    
    return new Proxy(this, {
      set: (target, prop, value, receiver) => {
        const schemaFields = new Set(['id', 'title', 'content', 'authorId', 'createdAt']);
        if (!schemaFields.has(prop as string)) {
          return Reflect.set(target, prop, value, receiver);
        }

        const builder = new Builder(1024);
        const data = { id: (prop === 'id') ? value : target.fbb.id(), title: (prop === 'title') ? value : target.fbb.title(), content: (prop === 'content') ? value : target.fbb.content(), authorId: (prop === 'authorId') ? value : target.fbb.authorId(), createdAt: (prop === 'createdAt') ? value : target.fbb.createdAt() };
        
    const idOffset = data.id ? builder.createString(data.id) : 0;
    const titleOffset = data.title ? builder.createString(data.title) : 0;
    const contentOffset = data.content ? builder.createString(data.content) : 0;
    const authorIdOffset = data.authorId ? builder.createString(data.authorId) : 0;
        
        const entityOffset = LowLevel.createPost(builder, idOffset, titleOffset, contentOffset, authorIdOffset, data.createdAt);
        builder.finish(entityOffset);
        const buffer = builder.asUint8Array();

        target.db.update(
          'Post',
          target.id,
          buffer
        );
        
        const newFbb = getRootAs(new ByteBuffer(buffer), 'Post') as LowLevel.Post;
        target.fbb = newFbb;

        return true;
      }
    });
  }

  // --- Fields ---
  get id(): string | null {
    return this.fbb.id();
  }

  get title(): string | null {
    return this.fbb.title();
  }

  get content(): string | null {
    return this.fbb.content();
  }

  get authorId(): string | null {
    return this.fbb.authorId();
  }

  get createdAt(): bigint {
    return this.fbb.createdAt();
  }

  // --- Relationships ---
  get author(): UserNode<TActor> | null {
    const id = this.fbb.authorId();
    if (!id) return null;
    return this.db.get(
      'User',
       id,
       (db, fbb, ac) => new UserNode<TActor>(db, fbb, ac),
       (bb) => getRootAs(bb, 'User') as LowLevel.User,
       this.authContext
    ) as UserNode<TActor> | null;
  }

  get comments(): CommentNode<TActor> | null {
    const id = this.fbb.commentsId();
    if (!id) return null;
    return this.db.get(
      'Comment',
       id,
       (db, fbb, ac) => new CommentNode<TActor>(db, fbb, ac),
       (bb) => getRootAs(bb, 'Comment') as LowLevel.Comment,
       this.authContext
    ) as CommentNode<TActor> | null;
  }

  get images(): ImageNode<TActor> | null {
    const id = this.fbb.imagesId();
    if (!id) return null;
    return this.db.get(
      'Image',
       id,
       (db, fbb, ac) => new ImageNode<TActor>(db, fbb, ac),
       (bb) => getRootAs(bb, 'Image') as LowLevel.Image,
       this.authContext
    ) as ImageNode<TActor> | null;
  }

  get reactions(): ReactionNode<TActor> | null {
    const id = this.fbb.reactionsId();
    if (!id) return null;
    return this.db.get(
      'Reaction',
       id,
       (db, fbb, ac) => new ReactionNode<TActor>(db, fbb, ac),
       (bb) => getRootAs(bb, 'Reaction') as LowLevel.Reaction,
       this.authContext
    ) as ReactionNode<TActor> | null;
  }
}

export class CommentNode<TActor> extends ZgBaseNode<LowLevel.Comment, TActor> {
  constructor(
    db: ZgDatabase,
    fbb: LowLevel.Comment,
    authContext: ZgAuthContext<TActor> | null
  ) {
    super(db, fbb, authContext);
    
    return new Proxy(this, {
      set: (target, prop, value, receiver) => {
        const schemaFields = new Set(['id', 'content', 'authorId', 'postId', 'createdAt']);
        if (!schemaFields.has(prop as string)) {
          return Reflect.set(target, prop, value, receiver);
        }

        const builder = new Builder(1024);
        const data = { id: (prop === 'id') ? value : target.fbb.id(), content: (prop === 'content') ? value : target.fbb.content(), authorId: (prop === 'authorId') ? value : target.fbb.authorId(), postId: (prop === 'postId') ? value : target.fbb.postId(), createdAt: (prop === 'createdAt') ? value : target.fbb.createdAt() };
        
    const idOffset = data.id ? builder.createString(data.id) : 0;
    const contentOffset = data.content ? builder.createString(data.content) : 0;
    const authorIdOffset = data.authorId ? builder.createString(data.authorId) : 0;
    const postIdOffset = data.postId ? builder.createString(data.postId) : 0;
        
        const entityOffset = LowLevel.createComment(builder, idOffset, contentOffset, authorIdOffset, postIdOffset, data.createdAt);
        builder.finish(entityOffset);
        const buffer = builder.asUint8Array();

        target.db.update(
          'Comment',
          target.id,
          buffer
        );
        
        const newFbb = getRootAs(new ByteBuffer(buffer), 'Comment') as LowLevel.Comment;
        target.fbb = newFbb;

        return true;
      }
    });
  }

  // --- Fields ---
  get id(): string | null {
    return this.fbb.id();
  }

  get content(): string | null {
    return this.fbb.content();
  }

  get authorId(): string | null {
    return this.fbb.authorId();
  }

  get postId(): string | null {
    return this.fbb.postId();
  }

  get createdAt(): bigint {
    return this.fbb.createdAt();
  }

  // --- Relationships ---
  get author(): UserNode<TActor> | null {
    const id = this.fbb.authorId();
    if (!id) return null;
    return this.db.get(
      'User',
       id,
       (db, fbb, ac) => new UserNode<TActor>(db, fbb, ac),
       (bb) => getRootAs(bb, 'User') as LowLevel.User,
       this.authContext
    ) as UserNode<TActor> | null;
  }

  get post(): PostNode<TActor> | null {
    const id = this.fbb.postId();
    if (!id) return null;
    return this.db.get(
      'Post',
       id,
       (db, fbb, ac) => new PostNode<TActor>(db, fbb, ac),
       (bb) => getRootAs(bb, 'Post') as LowLevel.Post,
       this.authContext
    ) as PostNode<TActor> | null;
  }

  get reactions(): ReactionNode<TActor> | null {
    const id = this.fbb.reactionsId();
    if (!id) return null;
    return this.db.get(
      'Reaction',
       id,
       (db, fbb, ac) => new ReactionNode<TActor>(db, fbb, ac),
       (bb) => getRootAs(bb, 'Reaction') as LowLevel.Reaction,
       this.authContext
    ) as ReactionNode<TActor> | null;
  }
}

export class FollowNode<TActor> extends ZgBaseNode<LowLevel.Follow, TActor> {
  constructor(
    db: ZgDatabase,
    fbb: LowLevel.Follow,
    authContext: ZgAuthContext<TActor> | null
  ) {
    super(db, fbb, authContext);
    
    return new Proxy(this, {
      set: (target, prop, value, receiver) => {
        const schemaFields = new Set(['id', 'followerId', 'followingId', 'createdAt']);
        if (!schemaFields.has(prop as string)) {
          return Reflect.set(target, prop, value, receiver);
        }

        const builder = new Builder(1024);
        const data = { id: (prop === 'id') ? value : target.fbb.id(), followerId: (prop === 'followerId') ? value : target.fbb.followerId(), followingId: (prop === 'followingId') ? value : target.fbb.followingId(), createdAt: (prop === 'createdAt') ? value : target.fbb.createdAt() };
        
    const idOffset = data.id ? builder.createString(data.id) : 0;
    const followerIdOffset = data.followerId ? builder.createString(data.followerId) : 0;
    const followingIdOffset = data.followingId ? builder.createString(data.followingId) : 0;
        
        const entityOffset = LowLevel.createFollow(builder, idOffset, followerIdOffset, followingIdOffset, data.createdAt);
        builder.finish(entityOffset);
        const buffer = builder.asUint8Array();

        target.db.update(
          'Follow',
          target.id,
          buffer
        );
        
        const newFbb = getRootAs(new ByteBuffer(buffer), 'Follow') as LowLevel.Follow;
        target.fbb = newFbb;

        return true;
      }
    });
  }

  // --- Fields ---
  get id(): string | null {
    return this.fbb.id();
  }

  get followerId(): string | null {
    return this.fbb.followerId();
  }

  get followingId(): string | null {
    return this.fbb.followingId();
  }

  get createdAt(): bigint {
    return this.fbb.createdAt();
  }

  // --- Relationships ---
  get follower(): UserNode<TActor> | null {
    const id = this.fbb.followerId();
    if (!id) return null;
    return this.db.get(
      'User',
       id,
       (db, fbb, ac) => new UserNode<TActor>(db, fbb, ac),
       (bb) => getRootAs(bb, 'User') as LowLevel.User,
       this.authContext
    ) as UserNode<TActor> | null;
  }

  get following(): UserNode<TActor> | null {
    const id = this.fbb.followingId();
    if (!id) return null;
    return this.db.get(
      'User',
       id,
       (db, fbb, ac) => new UserNode<TActor>(db, fbb, ac),
       (bb) => getRootAs(bb, 'User') as LowLevel.User,
       this.authContext
    ) as UserNode<TActor> | null;
  }
}

export class Image_MetadataNode<TActor> extends ZgBaseNode<LowLevel.Image_Metadata, TActor> {
  constructor(
    db: ZgDatabase,
    fbb: LowLevel.Image_Metadata,
    authContext: ZgAuthContext<TActor> | null
  ) {
    super(db, fbb, authContext);
    
    return new Proxy(this, {
      set: (target, prop, value, receiver) => {
        const schemaFields = new Set(['width', 'height', 'format', 'createdAt']);
        if (!schemaFields.has(prop as string)) {
          return Reflect.set(target, prop, value, receiver);
        }

        const builder = new Builder(1024);
        const data = { width: (prop === 'width') ? value : target.fbb.width(), height: (prop === 'height') ? value : target.fbb.height(), format: (prop === 'format') ? value : target.fbb.format(), createdAt: (prop === 'createdAt') ? value : target.fbb.createdAt() };
        
    const formatOffset = data.format ? builder.createString(data.format) : 0;
        
        const entityOffset = LowLevel.createImage_Metadata(builder, data.width, data.height, formatOffset, data.createdAt);
        builder.finish(entityOffset);
        const buffer = builder.asUint8Array();

        target.db.update(
          'Image_Metadata',
          target.id,
          buffer
        );
        
        const newFbb = getRootAs(new ByteBuffer(buffer), 'Image_Metadata') as LowLevel.Image_Metadata;
        target.fbb = newFbb;

        return true;
      }
    });
  }

  // --- Fields ---
  get width(): bigint {
    return this.fbb.width();
  }

  get height(): bigint {
    return this.fbb.height();
  }

  get format(): string | null {
    return this.fbb.format();
  }

  get createdAt(): bigint {
    return this.fbb.createdAt();
  }

  // --- Relationships ---

}

export class ImageNode<TActor> extends ZgBaseNode<LowLevel.Image, TActor> {
  constructor(
    db: ZgDatabase,
    fbb: LowLevel.Image,
    authContext: ZgAuthContext<TActor> | null
  ) {
    super(db, fbb, authContext);
    
    return new Proxy(this, {
      set: (target, prop, value, receiver) => {
        const schemaFields = new Set(['id', 'url', 'fartCount', 'altText', 'metadata', 'postId', 'userId']);
        if (!schemaFields.has(prop as string)) {
          return Reflect.set(target, prop, value, receiver);
        }

        const builder = new Builder(1024);
        const data = { id: (prop === 'id') ? value : target.fbb.id(), url: (prop === 'url') ? value : target.fbb.url(), fartCount: (prop === 'fartCount') ? value : target.fbb.fartCount(), altText: (prop === 'altText') ? value : target.fbb.altText(), metadata: (prop === 'metadata') ? value : target.fbb.metadata(), postId: (prop === 'postId') ? value : target.fbb.postId(), userId: (prop === 'userId') ? value : target.fbb.userId() };
        
    const idOffset = data.id ? builder.createString(data.id) : 0;
    const urlOffset = data.url ? builder.createString(data.url) : 0;
    const altTextOffset = data.altText ? builder.createString(data.altText) : 0;
    const postIdOffset = data.postId ? builder.createString(data.postId) : 0;
    const userIdOffset = data.userId ? builder.createString(data.userId) : 0;
        
        const entityOffset = LowLevel.createImage(builder, idOffset, urlOffset, data.fartCount, altTextOffset, data.metadata, postIdOffset, userIdOffset);
        builder.finish(entityOffset);
        const buffer = builder.asUint8Array();

        target.db.update(
          'Image',
          target.id,
          buffer
        );
        
        const newFbb = getRootAs(new ByteBuffer(buffer), 'Image') as LowLevel.Image;
        target.fbb = newFbb;

        return true;
      }
    });
  }

  // --- Fields ---
  get id(): string | null {
    return this.fbb.id();
  }

  get url(): string | null {
    return this.fbb.url();
  }

  get fartCount(): bigint {
    return this.fbb.fartCount();
  }

  get altText(): string | null {
    return this.fbb.altText();
  }

  get metadata(): any {
    return this.fbb.metadata();
  }

  get postId(): string | null {
    return this.fbb.postId();
  }

  get userId(): string | null {
    return this.fbb.userId();
  }

  // --- Relationships ---
  get post(): PostNode<TActor> | null {
    const id = this.fbb.postId();
    if (!id) return null;
    return this.db.get(
      'Post',
       id,
       (db, fbb, ac) => new PostNode<TActor>(db, fbb, ac),
       (bb) => getRootAs(bb, 'Post') as LowLevel.Post,
       this.authContext
    ) as PostNode<TActor> | null;
  }

  get user(): UserNode<TActor> | null {
    const id = this.fbb.userId();
    if (!id) return null;
    return this.db.get(
      'User',
       id,
       (db, fbb, ac) => new UserNode<TActor>(db, fbb, ac),
       (bb) => getRootAs(bb, 'User') as LowLevel.User,
       this.authContext
    ) as UserNode<TActor> | null;
  }
}

export class ReactionNode<TActor> extends ZgBaseNode<LowLevel.Reaction, TActor> {
  constructor(
    db: ZgDatabase,
    fbb: LowLevel.Reaction,
    authContext: ZgAuthContext<TActor> | null
  ) {
    super(db, fbb, authContext);
    
    return new Proxy(this, {
      set: (target, prop, value, receiver) => {
        const schemaFields = new Set(['id', 'type', 'authorId', 'targetId', 'targetType']);
        if (!schemaFields.has(prop as string)) {
          return Reflect.set(target, prop, value, receiver);
        }

        const builder = new Builder(1024);
        const data = { id: (prop === 'id') ? value : target.fbb.id(), type: (prop === 'type') ? value : target.fbb.type(), authorId: (prop === 'authorId') ? value : target.fbb.authorId(), targetId: (prop === 'targetId') ? value : target.fbb.targetId(), targetType: (prop === 'targetType') ? value : target.fbb.targetType() };
        
    const idOffset = data.id ? builder.createString(data.id) : 0;
    const typeOffset = data.type ? builder.createString(data.type) : 0;
    const authorIdOffset = data.authorId ? builder.createString(data.authorId) : 0;
    const targetIdOffset = data.targetId ? builder.createString(data.targetId) : 0;
    const targetTypeOffset = data.targetType ? builder.createString(data.targetType) : 0;
        
        const entityOffset = LowLevel.createReaction(builder, idOffset, typeOffset, authorIdOffset, targetIdOffset, targetTypeOffset);
        builder.finish(entityOffset);
        const buffer = builder.asUint8Array();

        target.db.update(
          'Reaction',
          target.id,
          buffer
        );
        
        const newFbb = getRootAs(new ByteBuffer(buffer), 'Reaction') as LowLevel.Reaction;
        target.fbb = newFbb;

        return true;
      }
    });
  }

  // --- Fields ---
  get id(): string | null {
    return this.fbb.id();
  }

  get type(): string | null {
    return this.fbb.type();
  }

  get authorId(): string | null {
    return this.fbb.authorId();
  }

  get targetId(): string | null {
    return this.fbb.targetId();
  }

  get targetType(): string | null {
    return this.fbb.targetType();
  }

  // --- Relationships ---
  get author(): UserNode<TActor> | null {
    const id = this.fbb.authorId();
    if (!id) return null;
    return this.db.get(
      'User',
       id,
       (db, fbb, ac) => new UserNode<TActor>(db, fbb, ac),
       (bb) => getRootAs(bb, 'User') as LowLevel.User,
       this.authContext
    ) as UserNode<TActor> | null;
  }
}

export class TagNode<TActor> extends ZgBaseNode<LowLevel.Tag, TActor> {
  constructor(
    db: ZgDatabase,
    fbb: LowLevel.Tag,
    authContext: ZgAuthContext<TActor> | null
  ) {
    super(db, fbb, authContext);
    
    return new Proxy(this, {
      set: (target, prop, value, receiver) => {
        const schemaFields = new Set(['id', 'name']);
        if (!schemaFields.has(prop as string)) {
          return Reflect.set(target, prop, value, receiver);
        }

        const builder = new Builder(1024);
        const data = { id: (prop === 'id') ? value : target.fbb.id(), name: (prop === 'name') ? value : target.fbb.name() };
        
    const idOffset = data.id ? builder.createString(data.id) : 0;
    const nameOffset = data.name ? builder.createString(data.name) : 0;
        
        const entityOffset = LowLevel.createTag(builder, idOffset, nameOffset);
        builder.finish(entityOffset);
        const buffer = builder.asUint8Array();

        target.db.update(
          'Tag',
          target.id,
          buffer
        );
        
        const newFbb = getRootAs(new ByteBuffer(buffer), 'Tag') as LowLevel.Tag;
        target.fbb = newFbb;

        return true;
      }
    });
  }

  // --- Fields ---
  get id(): string | null {
    return this.fbb.id();
  }

  get name(): string | null {
    return this.fbb.name();
  }

  // --- Relationships ---

}

export class PostTagNode<TActor> extends ZgBaseNode<LowLevel.PostTag, TActor> {
  constructor(
    db: ZgDatabase,
    fbb: LowLevel.PostTag,
    authContext: ZgAuthContext<TActor> | null
  ) {
    super(db, fbb, authContext);
    
    return new Proxy(this, {
      set: (target, prop, value, receiver) => {
        const schemaFields = new Set(['id', 'postId', 'tagId']);
        if (!schemaFields.has(prop as string)) {
          return Reflect.set(target, prop, value, receiver);
        }

        const builder = new Builder(1024);
        const data = { id: (prop === 'id') ? value : target.fbb.id(), postId: (prop === 'postId') ? value : target.fbb.postId(), tagId: (prop === 'tagId') ? value : target.fbb.tagId() };
        
    const idOffset = data.id ? builder.createString(data.id) : 0;
    const postIdOffset = data.postId ? builder.createString(data.postId) : 0;
    const tagIdOffset = data.tagId ? builder.createString(data.tagId) : 0;
        
        const entityOffset = LowLevel.createPostTag(builder, idOffset, postIdOffset, tagIdOffset);
        builder.finish(entityOffset);
        const buffer = builder.asUint8Array();

        target.db.update(
          'PostTag',
          target.id,
          buffer
        );
        
        const newFbb = getRootAs(new ByteBuffer(buffer), 'PostTag') as LowLevel.PostTag;
        target.fbb = newFbb;

        return true;
      }
    });
  }

  // --- Fields ---
  get id(): string | null {
    return this.fbb.id();
  }

  get postId(): string | null {
    return this.fbb.postId();
  }

  get tagId(): string | null {
    return this.fbb.tagId();
  }

  // --- Relationships ---
  get post(): PostNode<TActor> | null {
    const id = this.fbb.postId();
    if (!id) return null;
    return this.db.get(
      'Post',
       id,
       (db, fbb, ac) => new PostNode<TActor>(db, fbb, ac),
       (bb) => getRootAs(bb, 'Post') as LowLevel.Post,
       this.authContext
    ) as PostNode<TActor> | null;
  }

  get tag(): TagNode<TActor> | null {
    const id = this.fbb.tagId();
    if (!id) return null;
    return this.db.get(
      'Tag',
       id,
       (db, fbb, ac) => new TagNode<TActor>(db, fbb, ac),
       (bb) => getRootAs(bb, 'Tag') as LowLevel.Tag,
       this.authContext
    ) as TagNode<TActor> | null;
  }
}

// --- Database Class ---
export class ZgClient<
  TActor,
  TGlobalResolvers extends ResolverMap,
  TEntityResolvers extends Record<string, ResolverMap>
> {
  private db: ZgDatabase;
  private authContext: ZgAuthContext<TActor>;

  constructor(db: ZgDatabase, authContext: ZgAuthContext<TActor>) {
    this.db = db;
    this.authContext = authContext;
  }

  get users() {
    return {
      get: (id: string): ResolvedNode<UserNode<TActor>, TEntityResolvers["User"], TGlobalResolvers> | null => {
        return this.db.get<LowLevel.User, UserNode<TActor>>(
          'User',
          id,
          (db, fbb, ac) => new UserNode<TActor>(db, fbb, ac),
          (bb) => LowLevel.User.getRootAsUser(bb),
          this.authContext,
        ) as ResolvedNode<UserNode<TActor>, TEntityResolvers["User"], TGlobalResolvers> | null;
      },
      create: (data: { id: string, publicKey: string, displayName: string, avatarUrl: string }): ResolvedNode<UserNode<TActor>, TEntityResolvers["User"], TGlobalResolvers> => {
        const builder = new Builder(1024);
        
    const idOffset = builder.createString(data.id);
    const publicKeyOffset = builder.createString(data.publicKey);
    const displayNameOffset = builder.createString(data.displayName);
    const avatarUrlOffset = builder.createString(data.avatarUrl);
        
        const entityOffset = LowLevel.User.createUser(builder, idOffset, publicKeyOffset, displayNameOffset, avatarUrlOffset);
        builder.finish(entityOffset);
        
        const buffer = builder.asUint8Array();
        
        if (!data.id || typeof data.id !== 'string') {
          throw new Error("The 'id' field is required and must be a string to create an entity.");
        }

        return this.db.create<LowLevel.User, UserNode<TActor>>(
          'User',
          data.id,
          buffer,
          (db, fbb, ac) => new UserNode<TActor>(db, fbb, ac),
          (bb) => LowLevel.User.getRootAsUser(bb),
          this.authContext,
        ) as ResolvedNode<UserNode<TActor>, TEntityResolvers["User"], TGlobalResolvers>;
      },
      update: (id: string, data: Partial<{ id: string, publicKey: string, displayName: string, avatarUrl: string }>): ResolvedNode<UserNode<TActor>, TEntityResolvers["User"], TGlobalResolvers> => {
        // Update is more complex: it requires getting the old buffer,
        // parsing it, creating a new buffer with the merged data,
        // and then writing it back. This is a placeholder.
        throw new Error("Update is not implemented yet.");
      },
    };
  }

  get posts() {
    return {
      get: (id: string): ResolvedNode<PostNode<TActor>, TEntityResolvers["Post"], TGlobalResolvers> | null => {
        return this.db.get<LowLevel.Post, PostNode<TActor>>(
          'Post',
          id,
          (db, fbb, ac) => new PostNode<TActor>(db, fbb, ac),
          (bb) => LowLevel.Post.getRootAsPost(bb),
          this.authContext,
        ) as ResolvedNode<PostNode<TActor>, TEntityResolvers["Post"], TGlobalResolvers> | null;
      },
      create: (data: { id: string, title: string, content: string, authorId: string, createdAt: bigint }): ResolvedNode<PostNode<TActor>, TEntityResolvers["Post"], TGlobalResolvers> => {
        const builder = new Builder(1024);
        
    const idOffset = builder.createString(data.id);
    const titleOffset = builder.createString(data.title);
    const contentOffset = builder.createString(data.content);
    const authorIdOffset = builder.createString(data.authorId);
        
        const entityOffset = LowLevel.Post.createPost(builder, idOffset, titleOffset, contentOffset, authorIdOffset, data.createdAt);
        builder.finish(entityOffset);
        
        const buffer = builder.asUint8Array();
        
        if (!data.id || typeof data.id !== 'string') {
          throw new Error("The 'id' field is required and must be a string to create an entity.");
        }

        return this.db.create<LowLevel.Post, PostNode<TActor>>(
          'Post',
          data.id,
          buffer,
          (db, fbb, ac) => new PostNode<TActor>(db, fbb, ac),
          (bb) => LowLevel.Post.getRootAsPost(bb),
          this.authContext,
        ) as ResolvedNode<PostNode<TActor>, TEntityResolvers["Post"], TGlobalResolvers>;
      },
      update: (id: string, data: Partial<{ id: string, title: string, content: string, authorId: string, createdAt: bigint }>): ResolvedNode<PostNode<TActor>, TEntityResolvers["Post"], TGlobalResolvers> => {
        // Update is more complex: it requires getting the old buffer,
        // parsing it, creating a new buffer with the merged data,
        // and then writing it back. This is a placeholder.
        throw new Error("Update is not implemented yet.");
      },
    };
  }

  get comments() {
    return {
      get: (id: string): ResolvedNode<CommentNode<TActor>, TEntityResolvers["Comment"], TGlobalResolvers> | null => {
        return this.db.get<LowLevel.Comment, CommentNode<TActor>>(
          'Comment',
          id,
          (db, fbb, ac) => new CommentNode<TActor>(db, fbb, ac),
          (bb) => LowLevel.Comment.getRootAsComment(bb),
          this.authContext,
        ) as ResolvedNode<CommentNode<TActor>, TEntityResolvers["Comment"], TGlobalResolvers> | null;
      },
      create: (data: { id: string, content: string, authorId: string, postId: string, createdAt: bigint }): ResolvedNode<CommentNode<TActor>, TEntityResolvers["Comment"], TGlobalResolvers> => {
        const builder = new Builder(1024);
        
    const idOffset = builder.createString(data.id);
    const contentOffset = builder.createString(data.content);
    const authorIdOffset = builder.createString(data.authorId);
    const postIdOffset = builder.createString(data.postId);
        
        const entityOffset = LowLevel.Comment.createComment(builder, idOffset, contentOffset, authorIdOffset, postIdOffset, data.createdAt);
        builder.finish(entityOffset);
        
        const buffer = builder.asUint8Array();
        
        if (!data.id || typeof data.id !== 'string') {
          throw new Error("The 'id' field is required and must be a string to create an entity.");
        }

        return this.db.create<LowLevel.Comment, CommentNode<TActor>>(
          'Comment',
          data.id,
          buffer,
          (db, fbb, ac) => new CommentNode<TActor>(db, fbb, ac),
          (bb) => LowLevel.Comment.getRootAsComment(bb),
          this.authContext,
        ) as ResolvedNode<CommentNode<TActor>, TEntityResolvers["Comment"], TGlobalResolvers>;
      },
      update: (id: string, data: Partial<{ id: string, content: string, authorId: string, postId: string, createdAt: bigint }>): ResolvedNode<CommentNode<TActor>, TEntityResolvers["Comment"], TGlobalResolvers> => {
        // Update is more complex: it requires getting the old buffer,
        // parsing it, creating a new buffer with the merged data,
        // and then writing it back. This is a placeholder.
        throw new Error("Update is not implemented yet.");
      },
    };
  }

  get follows() {
    return {
      get: (id: string): ResolvedNode<FollowNode<TActor>, TEntityResolvers["Follow"], TGlobalResolvers> | null => {
        return this.db.get<LowLevel.Follow, FollowNode<TActor>>(
          'Follow',
          id,
          (db, fbb, ac) => new FollowNode<TActor>(db, fbb, ac),
          (bb) => LowLevel.Follow.getRootAsFollow(bb),
          this.authContext,
        ) as ResolvedNode<FollowNode<TActor>, TEntityResolvers["Follow"], TGlobalResolvers> | null;
      },
      create: (data: { id: string, followerId: string, followingId: string, createdAt: bigint }): ResolvedNode<FollowNode<TActor>, TEntityResolvers["Follow"], TGlobalResolvers> => {
        const builder = new Builder(1024);
        
    const idOffset = builder.createString(data.id);
    const followerIdOffset = builder.createString(data.followerId);
    const followingIdOffset = builder.createString(data.followingId);
        
        const entityOffset = LowLevel.Follow.createFollow(builder, idOffset, followerIdOffset, followingIdOffset, data.createdAt);
        builder.finish(entityOffset);
        
        const buffer = builder.asUint8Array();
        
        if (!data.id || typeof data.id !== 'string') {
          throw new Error("The 'id' field is required and must be a string to create an entity.");
        }

        return this.db.create<LowLevel.Follow, FollowNode<TActor>>(
          'Follow',
          data.id,
          buffer,
          (db, fbb, ac) => new FollowNode<TActor>(db, fbb, ac),
          (bb) => LowLevel.Follow.getRootAsFollow(bb),
          this.authContext,
        ) as ResolvedNode<FollowNode<TActor>, TEntityResolvers["Follow"], TGlobalResolvers>;
      },
      update: (id: string, data: Partial<{ id: string, followerId: string, followingId: string, createdAt: bigint }>): ResolvedNode<FollowNode<TActor>, TEntityResolvers["Follow"], TGlobalResolvers> => {
        // Update is more complex: it requires getting the old buffer,
        // parsing it, creating a new buffer with the merged data,
        // and then writing it back. This is a placeholder.
        throw new Error("Update is not implemented yet.");
      },
    };
  }

  get image_Metadatas() {
    return {
      get: (id: string): ResolvedNode<Image_MetadataNode<TActor>, TEntityResolvers["Image_Metadata"], TGlobalResolvers> | null => {
        return this.db.get<LowLevel.Image_Metadata, Image_MetadataNode<TActor>>(
          'Image_Metadata',
          id,
          (db, fbb, ac) => new Image_MetadataNode<TActor>(db, fbb, ac),
          (bb) => LowLevel.Image_Metadata.getRootAsImage_Metadata(bb),
          this.authContext,
        ) as ResolvedNode<Image_MetadataNode<TActor>, TEntityResolvers["Image_Metadata"], TGlobalResolvers> | null;
      },
      create: (data: { width: bigint, height: bigint, format: string, createdAt: bigint }): ResolvedNode<Image_MetadataNode<TActor>, TEntityResolvers["Image_Metadata"], TGlobalResolvers> => {
        const builder = new Builder(1024);
        
    const formatOffset = builder.createString(data.format);
        
        const entityOffset = LowLevel.Image_Metadata.createImage_Metadata(builder, data.width, data.height, formatOffset, data.createdAt);
        builder.finish(entityOffset);
        
        const buffer = builder.asUint8Array();
        
        if (!data.id || typeof data.id !== 'string') {
          throw new Error("The 'id' field is required and must be a string to create an entity.");
        }

        return this.db.create<LowLevel.Image_Metadata, Image_MetadataNode<TActor>>(
          'Image_Metadata',
          data.id,
          buffer,
          (db, fbb, ac) => new Image_MetadataNode<TActor>(db, fbb, ac),
          (bb) => LowLevel.Image_Metadata.getRootAsImage_Metadata(bb),
          this.authContext,
        ) as ResolvedNode<Image_MetadataNode<TActor>, TEntityResolvers["Image_Metadata"], TGlobalResolvers>;
      },
      update: (id: string, data: Partial<{ width: bigint, height: bigint, format: string, createdAt: bigint }>): ResolvedNode<Image_MetadataNode<TActor>, TEntityResolvers["Image_Metadata"], TGlobalResolvers> => {
        // Update is more complex: it requires getting the old buffer,
        // parsing it, creating a new buffer with the merged data,
        // and then writing it back. This is a placeholder.
        throw new Error("Update is not implemented yet.");
      },
    };
  }

  get images() {
    return {
      get: (id: string): ResolvedNode<ImageNode<TActor>, TEntityResolvers["Image"], TGlobalResolvers> | null => {
        return this.db.get<LowLevel.Image, ImageNode<TActor>>(
          'Image',
          id,
          (db, fbb, ac) => new ImageNode<TActor>(db, fbb, ac),
          (bb) => LowLevel.Image.getRootAsImage(bb),
          this.authContext,
        ) as ResolvedNode<ImageNode<TActor>, TEntityResolvers["Image"], TGlobalResolvers> | null;
      },
      create: (data: { id: string, url: string, fartCount: bigint, altText: string, metadata: any, postId: string, userId: string }): ResolvedNode<ImageNode<TActor>, TEntityResolvers["Image"], TGlobalResolvers> => {
        const builder = new Builder(1024);
        
    const idOffset = builder.createString(data.id);
    const urlOffset = builder.createString(data.url);
    const altTextOffset = builder.createString(data.altText);
    const postIdOffset = builder.createString(data.postId);
    const userIdOffset = builder.createString(data.userId);
        
        const entityOffset = LowLevel.Image.createImage(builder, idOffset, urlOffset, data.fartCount, altTextOffset, data.metadata, postIdOffset, userIdOffset);
        builder.finish(entityOffset);
        
        const buffer = builder.asUint8Array();
        
        if (!data.id || typeof data.id !== 'string') {
          throw new Error("The 'id' field is required and must be a string to create an entity.");
        }

        return this.db.create<LowLevel.Image, ImageNode<TActor>>(
          'Image',
          data.id,
          buffer,
          (db, fbb, ac) => new ImageNode<TActor>(db, fbb, ac),
          (bb) => LowLevel.Image.getRootAsImage(bb),
          this.authContext,
        ) as ResolvedNode<ImageNode<TActor>, TEntityResolvers["Image"], TGlobalResolvers>;
      },
      update: (id: string, data: Partial<{ id: string, url: string, fartCount: bigint, altText: string, metadata: any, postId: string, userId: string }>): ResolvedNode<ImageNode<TActor>, TEntityResolvers["Image"], TGlobalResolvers> => {
        // Update is more complex: it requires getting the old buffer,
        // parsing it, creating a new buffer with the merged data,
        // and then writing it back. This is a placeholder.
        throw new Error("Update is not implemented yet.");
      },
    };
  }

  get reactions() {
    return {
      get: (id: string): ResolvedNode<ReactionNode<TActor>, TEntityResolvers["Reaction"], TGlobalResolvers> | null => {
        return this.db.get<LowLevel.Reaction, ReactionNode<TActor>>(
          'Reaction',
          id,
          (db, fbb, ac) => new ReactionNode<TActor>(db, fbb, ac),
          (bb) => LowLevel.Reaction.getRootAsReaction(bb),
          this.authContext,
        ) as ResolvedNode<ReactionNode<TActor>, TEntityResolvers["Reaction"], TGlobalResolvers> | null;
      },
      create: (data: { id: string, type: string, authorId: string, targetId: string, targetType: string }): ResolvedNode<ReactionNode<TActor>, TEntityResolvers["Reaction"], TGlobalResolvers> => {
        const builder = new Builder(1024);
        
    const idOffset = builder.createString(data.id);
    const typeOffset = builder.createString(data.type);
    const authorIdOffset = builder.createString(data.authorId);
    const targetIdOffset = builder.createString(data.targetId);
    const targetTypeOffset = builder.createString(data.targetType);
        
        const entityOffset = LowLevel.Reaction.createReaction(builder, idOffset, typeOffset, authorIdOffset, targetIdOffset, targetTypeOffset);
        builder.finish(entityOffset);
        
        const buffer = builder.asUint8Array();
        
        if (!data.id || typeof data.id !== 'string') {
          throw new Error("The 'id' field is required and must be a string to create an entity.");
        }

        return this.db.create<LowLevel.Reaction, ReactionNode<TActor>>(
          'Reaction',
          data.id,
          buffer,
          (db, fbb, ac) => new ReactionNode<TActor>(db, fbb, ac),
          (bb) => LowLevel.Reaction.getRootAsReaction(bb),
          this.authContext,
        ) as ResolvedNode<ReactionNode<TActor>, TEntityResolvers["Reaction"], TGlobalResolvers>;
      },
      update: (id: string, data: Partial<{ id: string, type: string, authorId: string, targetId: string, targetType: string }>): ResolvedNode<ReactionNode<TActor>, TEntityResolvers["Reaction"], TGlobalResolvers> => {
        // Update is more complex: it requires getting the old buffer,
        // parsing it, creating a new buffer with the merged data,
        // and then writing it back. This is a placeholder.
        throw new Error("Update is not implemented yet.");
      },
    };
  }

  get tags() {
    return {
      get: (id: string): ResolvedNode<TagNode<TActor>, TEntityResolvers["Tag"], TGlobalResolvers> | null => {
        return this.db.get<LowLevel.Tag, TagNode<TActor>>(
          'Tag',
          id,
          (db, fbb, ac) => new TagNode<TActor>(db, fbb, ac),
          (bb) => LowLevel.Tag.getRootAsTag(bb),
          this.authContext,
        ) as ResolvedNode<TagNode<TActor>, TEntityResolvers["Tag"], TGlobalResolvers> | null;
      },
      create: (data: { id: string, name: string }): ResolvedNode<TagNode<TActor>, TEntityResolvers["Tag"], TGlobalResolvers> => {
        const builder = new Builder(1024);
        
    const idOffset = builder.createString(data.id);
    const nameOffset = builder.createString(data.name);
        
        const entityOffset = LowLevel.Tag.createTag(builder, idOffset, nameOffset);
        builder.finish(entityOffset);
        
        const buffer = builder.asUint8Array();
        
        if (!data.id || typeof data.id !== 'string') {
          throw new Error("The 'id' field is required and must be a string to create an entity.");
        }

        return this.db.create<LowLevel.Tag, TagNode<TActor>>(
          'Tag',
          data.id,
          buffer,
          (db, fbb, ac) => new TagNode<TActor>(db, fbb, ac),
          (bb) => LowLevel.Tag.getRootAsTag(bb),
          this.authContext,
        ) as ResolvedNode<TagNode<TActor>, TEntityResolvers["Tag"], TGlobalResolvers>;
      },
      update: (id: string, data: Partial<{ id: string, name: string }>): ResolvedNode<TagNode<TActor>, TEntityResolvers["Tag"], TGlobalResolvers> => {
        // Update is more complex: it requires getting the old buffer,
        // parsing it, creating a new buffer with the merged data,
        // and then writing it back. This is a placeholder.
        throw new Error("Update is not implemented yet.");
      },
    };
  }

  get postTags() {
    return {
      get: (id: string): ResolvedNode<PostTagNode<TActor>, TEntityResolvers["PostTag"], TGlobalResolvers> | null => {
        return this.db.get<LowLevel.PostTag, PostTagNode<TActor>>(
          'PostTag',
          id,
          (db, fbb, ac) => new PostTagNode<TActor>(db, fbb, ac),
          (bb) => LowLevel.PostTag.getRootAsPostTag(bb),
          this.authContext,
        ) as ResolvedNode<PostTagNode<TActor>, TEntityResolvers["PostTag"], TGlobalResolvers> | null;
      },
      create: (data: { id: string, postId: string, tagId: string }): ResolvedNode<PostTagNode<TActor>, TEntityResolvers["PostTag"], TGlobalResolvers> => {
        const builder = new Builder(1024);
        
    const idOffset = builder.createString(data.id);
    const postIdOffset = builder.createString(data.postId);
    const tagIdOffset = builder.createString(data.tagId);
        
        const entityOffset = LowLevel.PostTag.createPostTag(builder, idOffset, postIdOffset, tagIdOffset);
        builder.finish(entityOffset);
        
        const buffer = builder.asUint8Array();
        
        if (!data.id || typeof data.id !== 'string') {
          throw new Error("The 'id' field is required and must be a string to create an entity.");
        }

        return this.db.create<LowLevel.PostTag, PostTagNode<TActor>>(
          'PostTag',
          data.id,
          buffer,
          (db, fbb, ac) => new PostTagNode<TActor>(db, fbb, ac),
          (bb) => LowLevel.PostTag.getRootAsPostTag(bb),
          this.authContext,
        ) as ResolvedNode<PostTagNode<TActor>, TEntityResolvers["PostTag"], TGlobalResolvers>;
      },
      update: (id: string, data: Partial<{ id: string, postId: string, tagId: string }>): ResolvedNode<PostTagNode<TActor>, TEntityResolvers["PostTag"], TGlobalResolvers> => {
        // Update is more complex: it requires getting the old buffer,
        // parsing it, creating a new buffer with the merged data,
        // and then writing it back. This is a placeholder.
        throw new Error("Update is not implemented yet.");
      },
    };
  }
}

// The main database instance, created once
class Database<
  TGlobalResolvers extends ResolverMap,
  TEntityResolvers extends Record<string, ResolverMap>
> {
  private db: ZgDatabase;

  constructor(config: {
    globalResolvers: TGlobalResolvers;
    entityResolvers: TEntityResolvers;
    auth: Record<string, any>;
  }) {
    this.db = new ZgDatabase(config);
  }

  createClient<TActor>(actor: TActor): ZgClient<TActor, TGlobalResolvers, TEntityResolvers> {
    return new ZgClient(this.db, { actor });
  }
}

export function createDB<
  TActor,
  const TGlobalResolvers extends ResolverMap,
  const TEntityResolvers extends Record<string, ResolverMap>
>(config: {
  globalResolvers: TGlobalResolvers;
  entityResolvers: TEntityResolvers;
  auth: Record<string, any>;
}): Database<TGlobalResolvers, TEntityResolvers> {
  return new Database(config);
}
