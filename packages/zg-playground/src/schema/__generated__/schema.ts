// @generated
// Automatically generated. Don't change this file manually.
// Name: schema.ts


// @ts-nocheck
// This file is generated by @zgdb/zg. Do not edit it manually.
// TODO: Generate based on the user's config
import { ZgDatabase, ZgBaseNode, ZgAuthContext, EntityCollection } from '@zgdb/client';
import { Builder, ByteBuffer } from 'flatbuffers';
import * as UserFB from './schema/user.js';
import * as PostFB from './schema/post.js';
import * as CommentFB from './schema/comment.js';
import * as FollowFB from './schema/follow.js';
import * as Image_MetadataFB from './schema/image-metadata.js';
import * as ImageFB from './schema/image.js';
import * as ReactionFB from './schema/reaction.js';
import * as TagFB from './schema/tag.js';
import * as PostTagFB from './schema/post-tag.js';


// --- Interfaces ---
export interface IUser {
  id: string;
  publicKey: string;
  displayName: string;
  avatarUrl: string;
}

export interface IPost {
  id: string;
  title: string;
  content: string;
  authorId: string;
  createdAt: bigint;
}

export interface IComment {
  id: string;
  content: string;
  authorId: string;
  postId: string;
  createdAt: bigint;
}

export interface IFollow {
  id: string;
  followerId: string;
  followingId: string;
  createdAt: bigint;
}

export interface IImage_Metadata {
  width: bigint;
  height: bigint;
  format: string;
  createdAt: bigint;
}

export interface IImage {
  id: string;
  url: string;
  fartCount: bigint;
  altText: string;
  metadata: any;
  postId: string;
  userId: string;
}

export interface IReaction {
  id: string;
  type: string;
  authorId: string;
  targetId: string;
  targetType: string;
}

export interface ITag {
  id: string;
  name: string;
}

export interface IPostTag {
  id: string;
  postId: string;
  tagId: string;
}

// --- Create Input Types ---
export type UserCreateInput = { id: string, publicKey: string, displayName: string, avatarUrl: string };
export type PostCreateInput = { id: string, title: string, content: string, authorId: string, createdAt: bigint };
export type CommentCreateInput = { id: string, content: string, authorId: string, postId: string, createdAt: bigint };
export type FollowCreateInput = { id: string, followerId: string, followingId: string, createdAt: bigint };
export type Image_MetadataCreateInput = { width: bigint, height: bigint, format: string, createdAt: bigint };
export type ImageCreateInput = { id: string, url: string, fartCount: bigint, altText: string, metadata: any, postId: string, userId: string };
export type ReactionCreateInput = { id: string, type: string, authorId: string, targetId: string, targetType: string };
export type TagCreateInput = { id: string, name: string };
export type PostTagCreateInput = { id: string, postId: string, tagId: string };

// --- Node Classes ---
export class UserNode<TActor> extends ZgBaseNode<UserFB.User, TActor> {
  constructor(
    db: ZgDatabase,
    fbb: UserFB.User,
    authContext: ZgAuthContext<TActor> | null
  ) {
    super(db, fbb, authContext);
    
    return new Proxy(this, {
      get: (target, prop, receiver) => {
        const entityResolvers = target.db.config.entityResolvers?.['User'] ?? {};
        if (prop in entityResolvers) {
          return entityResolvers[prop as keyof typeof entityResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        const globalResolvers = target.db.config.globalResolvers ?? {};
        if (prop in globalResolvers) {
          return globalResolvers[prop as keyof typeof globalResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        return Reflect.get(target, prop, receiver);
      },
      set: (target, prop, value, receiver) => {
        const schemaFields = new Set(['id', 'publicKey', 'displayName', 'avatarUrl']);
        if (!schemaFields.has(prop as string)) {
          return Reflect.set(target, prop, value, receiver);
        }

        const builder = new Builder(1024);
        const data = { id: (prop === 'id') ? value : target.fbb.id(), publicKey: (prop === 'publicKey') ? value : target.fbb.public_key(), displayName: (prop === 'displayName') ? value : target.fbb.display_name(), avatarUrl: (prop === 'avatarUrl') ? value : target.fbb.avatar_url() };
        
    const idOffset = data.id ? builder.createString(data.id) : 0;
    const publicKeyOffset = data.publicKey ? builder.createString(data.publicKey) : 0;
    const displayNameOffset = data.displayName ? builder.createString(data.displayName) : 0;
    const avatarUrlOffset = data.avatarUrl ? builder.createString(data.avatarUrl) : 0;
        
        const entityOffset = UserFB.User.createUser(builder, idOffset, publicKeyOffset, displayNameOffset, avatarUrlOffset);
        builder.finish(entityOffset);
        const buffer = builder.asUint8Array();

        target.db.update(
          'User',
          target.id,
          buffer
        );
        
        const newFbb = UserFB.User.getRootAsUser(new ByteBuffer(buffer));
        target.fbb = newFbb;

        return true;
      }
    });
  }

  // --- Fields ---
  get id(): string | null {
    return this.fbb.id();
  }

  get publicKey(): string | null {
    return this.fbb.public_key();
  }

  get displayName(): string | null {
    return this.fbb.display_name();
  }

  get avatarUrl(): string | null {
    return this.fbb.avatar_url();
  }

  // --- Relationships ---
  get posts(): PostNode<TActor>[] {
    // This is a placeholder implementation. A real implementation would use an index.
    const allNodes = Array.from(this.db.posts);
    // TODO: This is inefficient. We should use an index.
    return allNodes.filter(n => {
      const remoteNode = n as any;
      const fkValue = remoteNode.fbb.author_id();
      return fkValue === this.id;
    });
  }

  get comments(): CommentNode<TActor>[] {
    // This is a placeholder implementation. A real implementation would use an index.
    const allNodes = Array.from(this.db.comments);
    // TODO: This is inefficient. We should use an index.
    return allNodes.filter(n => {
      const remoteNode = n as any;
      const fkValue = remoteNode.fbb.author_id();
      return fkValue === this.id;
    });
  }

  get reactions(): ReactionNode<TActor>[] {
    // This is a placeholder implementation. A real implementation would use an index.
    const allNodes = Array.from(this.db.reactions);
    // TODO: This is inefficient. We should use an index.
    return allNodes.filter(n => {
      const remoteNode = n as any;
      const fkValue = remoteNode.fbb.author_id();
      return fkValue === this.id;
    });
  }

  get following(): FollowNode<TActor>[] {
    // This is a placeholder implementation. A real implementation would use an index.
    const allNodes = Array.from(this.db.follows);
    // TODO: This is inefficient. We should use an index.
    return allNodes.filter(n => {
      const remoteNode = n as any;
      const fkValue = remoteNode.fbb.follower_id();
      return fkValue === this.id;
    });
  }

  get followers(): FollowNode<TActor>[] {
    // This is a placeholder implementation. A real implementation would use an index.
    const allNodes = Array.from(this.db.follows);
    // TODO: This is inefficient. We should use an index.
    return allNodes.filter(n => {
      const remoteNode = n as any;
      const fkValue = remoteNode.fbb.following_id();
      return fkValue === this.id;
    });
  }
}

export class PostNode<TActor> extends ZgBaseNode<PostFB.Post, TActor> {
  constructor(
    db: ZgDatabase,
    fbb: PostFB.Post,
    authContext: ZgAuthContext<TActor> | null
  ) {
    super(db, fbb, authContext);
    
    return new Proxy(this, {
      get: (target, prop, receiver) => {
        const entityResolvers = target.db.config.entityResolvers?.['Post'] ?? {};
        if (prop in entityResolvers) {
          return entityResolvers[prop as keyof typeof entityResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        const globalResolvers = target.db.config.globalResolvers ?? {};
        if (prop in globalResolvers) {
          return globalResolvers[prop as keyof typeof globalResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        return Reflect.get(target, prop, receiver);
      },
      set: (target, prop, value, receiver) => {
        const schemaFields = new Set(['id', 'title', 'content', 'authorId', 'createdAt']);
        if (!schemaFields.has(prop as string)) {
          return Reflect.set(target, prop, value, receiver);
        }

        const builder = new Builder(1024);
        const data = { id: (prop === 'id') ? value : target.fbb.id(), title: (prop === 'title') ? value : target.fbb.title(), content: (prop === 'content') ? value : target.fbb.content(), authorId: (prop === 'authorId') ? value : target.fbb.author_id(), createdAt: (prop === 'createdAt') ? value : target.fbb.created_at() };
        
    const idOffset = data.id ? builder.createString(data.id) : 0;
    const titleOffset = data.title ? builder.createString(data.title) : 0;
    const contentOffset = data.content ? builder.createString(data.content) : 0;
    const authorIdOffset = data.authorId ? builder.createString(data.authorId) : 0;
        
        const entityOffset = PostFB.Post.createPost(builder, idOffset, titleOffset, contentOffset, authorIdOffset, data.createdAt);
        builder.finish(entityOffset);
        const buffer = builder.asUint8Array();

        target.db.update(
          'Post',
          target.id,
          buffer
        );
        
        const newFbb = PostFB.Post.getRootAsPost(new ByteBuffer(buffer));
        target.fbb = newFbb;

        return true;
      }
    });
  }

  // --- Fields ---
  get id(): string | null {
    return this.fbb.id();
  }

  get title(): string | null {
    return this.fbb.title();
  }

  get content(): string | null {
    return this.fbb.content();
  }

  get authorId(): string | null {
    return this.fbb.author_id();
  }

  get createdAt(): bigint {
    return this.fbb.created_at();
  }

  // --- Relationships ---
  get author(): UserNode<TActor> | null {
    const id = this.fbb.author_id();
    if (!id) return null;
    return this.db.get(
      'User',
       id,
       (db, fbb, ac) => new UserNode<TActor>(db, fbb, ac),
       (bb) => UserFB.User.getRootAsUser(bb),
       this.authContext
    ) as UserNode<TActor> | null;
  }

  get comments(): CommentNode<TActor>[] {
    // This is a placeholder implementation. A real implementation would use an index.
    const allNodes = Array.from(this.db.comments);
    // TODO: This is inefficient. We should use an index.
    return allNodes.filter(n => {
      const remoteNode = n as any;
      const fkValue = remoteNode.fbb.post_id();
      return fkValue === this.id;
    });
  }

  get images(): ImageNode<TActor>[] {
    // This is a placeholder implementation. A real implementation would use an index.
    const allNodes = Array.from(this.db.images);
    // TODO: This is inefficient. We should use an index.
    return allNodes.filter(n => {
      const remoteNode = n as any;
      const fkValue = remoteNode.fbb.post_id();
      return fkValue === this.id;
    });
  }

  get reactions(): ReactionNode<TActor>[] {
    // This is a placeholder implementation. A real implementation would use an index.
    const allNodes = Array.from(this.db.reactions);
    // TODO: This is inefficient. We should use an index.
    return allNodes.filter(n => {
      const remoteNode = n as any;
      const fkValue = remoteNode.fbb.target_id();
      return fkValue === this.id;
    });
  }
}

export class CommentNode<TActor> extends ZgBaseNode<CommentFB.Comment, TActor> {
  constructor(
    db: ZgDatabase,
    fbb: CommentFB.Comment,
    authContext: ZgAuthContext<TActor> | null
  ) {
    super(db, fbb, authContext);
    
    return new Proxy(this, {
      get: (target, prop, receiver) => {
        const entityResolvers = target.db.config.entityResolvers?.['Comment'] ?? {};
        if (prop in entityResolvers) {
          return entityResolvers[prop as keyof typeof entityResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        const globalResolvers = target.db.config.globalResolvers ?? {};
        if (prop in globalResolvers) {
          return globalResolvers[prop as keyof typeof globalResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        return Reflect.get(target, prop, receiver);
      },
      set: (target, prop, value, receiver) => {
        const schemaFields = new Set(['id', 'content', 'authorId', 'postId', 'createdAt']);
        if (!schemaFields.has(prop as string)) {
          return Reflect.set(target, prop, value, receiver);
        }

        const builder = new Builder(1024);
        const data = { id: (prop === 'id') ? value : target.fbb.id(), content: (prop === 'content') ? value : target.fbb.content(), authorId: (prop === 'authorId') ? value : target.fbb.author_id(), postId: (prop === 'postId') ? value : target.fbb.post_id(), createdAt: (prop === 'createdAt') ? value : target.fbb.created_at() };
        
    const idOffset = data.id ? builder.createString(data.id) : 0;
    const contentOffset = data.content ? builder.createString(data.content) : 0;
    const authorIdOffset = data.authorId ? builder.createString(data.authorId) : 0;
    const postIdOffset = data.postId ? builder.createString(data.postId) : 0;
        
        const entityOffset = CommentFB.Comment.createComment(builder, idOffset, contentOffset, authorIdOffset, postIdOffset, data.createdAt);
        builder.finish(entityOffset);
        const buffer = builder.asUint8Array();

        target.db.update(
          'Comment',
          target.id,
          buffer
        );
        
        const newFbb = CommentFB.Comment.getRootAsComment(new ByteBuffer(buffer));
        target.fbb = newFbb;

        return true;
      }
    });
  }

  // --- Fields ---
  get id(): string | null {
    return this.fbb.id();
  }

  get content(): string | null {
    return this.fbb.content();
  }

  get authorId(): string | null {
    return this.fbb.author_id();
  }

  get postId(): string | null {
    return this.fbb.post_id();
  }

  get createdAt(): bigint {
    return this.fbb.created_at();
  }

  // --- Relationships ---
  get author(): UserNode<TActor> | null {
    const id = this.fbb.author_id();
    if (!id) return null;
    return this.db.get(
      'User',
       id,
       (db, fbb, ac) => new UserNode<TActor>(db, fbb, ac),
       (bb) => UserFB.User.getRootAsUser(bb),
       this.authContext
    ) as UserNode<TActor> | null;
  }

  get post(): PostNode<TActor> | null {
    const id = this.fbb.post_id();
    if (!id) return null;
    return this.db.get(
      'Post',
       id,
       (db, fbb, ac) => new PostNode<TActor>(db, fbb, ac),
       (bb) => PostFB.Post.getRootAsPost(bb),
       this.authContext
    ) as PostNode<TActor> | null;
  }

  get reactions(): ReactionNode<TActor>[] {
    // This is a placeholder implementation. A real implementation would use an index.
    const allNodes = Array.from(this.db.reactions);
    // TODO: This is inefficient. We should use an index.
    return allNodes.filter(n => {
      const remoteNode = n as any;
      const fkValue = remoteNode.fbb.target_id();
      return fkValue === this.id;
    });
  }
}

export class FollowNode<TActor> extends ZgBaseNode<FollowFB.Follow, TActor> {
  constructor(
    db: ZgDatabase,
    fbb: FollowFB.Follow,
    authContext: ZgAuthContext<TActor> | null
  ) {
    super(db, fbb, authContext);
    
    return new Proxy(this, {
      get: (target, prop, receiver) => {
        const entityResolvers = target.db.config.entityResolvers?.['Follow'] ?? {};
        if (prop in entityResolvers) {
          return entityResolvers[prop as keyof typeof entityResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        const globalResolvers = target.db.config.globalResolvers ?? {};
        if (prop in globalResolvers) {
          return globalResolvers[prop as keyof typeof globalResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        return Reflect.get(target, prop, receiver);
      },
      set: (target, prop, value, receiver) => {
        const schemaFields = new Set(['id', 'followerId', 'followingId', 'createdAt']);
        if (!schemaFields.has(prop as string)) {
          return Reflect.set(target, prop, value, receiver);
        }

        const builder = new Builder(1024);
        const data = { id: (prop === 'id') ? value : target.fbb.id(), followerId: (prop === 'followerId') ? value : target.fbb.follower_id(), followingId: (prop === 'followingId') ? value : target.fbb.following_id(), createdAt: (prop === 'createdAt') ? value : target.fbb.created_at() };
        
    const idOffset = data.id ? builder.createString(data.id) : 0;
    const followerIdOffset = data.followerId ? builder.createString(data.followerId) : 0;
    const followingIdOffset = data.followingId ? builder.createString(data.followingId) : 0;
        
        const entityOffset = FollowFB.Follow.createFollow(builder, idOffset, followerIdOffset, followingIdOffset, data.createdAt);
        builder.finish(entityOffset);
        const buffer = builder.asUint8Array();

        target.db.update(
          'Follow',
          target.id,
          buffer
        );
        
        const newFbb = FollowFB.Follow.getRootAsFollow(new ByteBuffer(buffer));
        target.fbb = newFbb;

        return true;
      }
    });
  }

  // --- Fields ---
  get id(): string | null {
    return this.fbb.id();
  }

  get followerId(): string | null {
    return this.fbb.follower_id();
  }

  get followingId(): string | null {
    return this.fbb.following_id();
  }

  get createdAt(): bigint {
    return this.fbb.created_at();
  }

  // --- Relationships ---
  get follower(): UserNode<TActor> | null {
    const id = this.fbb.follower_id();
    if (!id) return null;
    return this.db.get(
      'User',
       id,
       (db, fbb, ac) => new UserNode<TActor>(db, fbb, ac),
       (bb) => UserFB.User.getRootAsUser(bb),
       this.authContext
    ) as UserNode<TActor> | null;
  }

  get following(): UserNode<TActor> | null {
    const id = this.fbb.following_id();
    if (!id) return null;
    return this.db.get(
      'User',
       id,
       (db, fbb, ac) => new UserNode<TActor>(db, fbb, ac),
       (bb) => UserFB.User.getRootAsUser(bb),
       this.authContext
    ) as UserNode<TActor> | null;
  }
}

export class Image_MetadataNode<TActor> extends ZgBaseNode<Image_MetadataFB.Image_Metadata, TActor> {
  constructor(
    db: ZgDatabase,
    fbb: Image_MetadataFB.Image_Metadata,
    authContext: ZgAuthContext<TActor> | null
  ) {
    super(db, fbb, authContext);
    
    return new Proxy(this, {
      get: (target, prop, receiver) => {
        const entityResolvers = target.db.config.entityResolvers?.['Image_Metadata'] ?? {};
        if (prop in entityResolvers) {
          return entityResolvers[prop as keyof typeof entityResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        const globalResolvers = target.db.config.globalResolvers ?? {};
        if (prop in globalResolvers) {
          return globalResolvers[prop as keyof typeof globalResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        return Reflect.get(target, prop, receiver);
      },
      set: (target, prop, value, receiver) => {
        const schemaFields = new Set(['width', 'height', 'format', 'createdAt']);
        if (!schemaFields.has(prop as string)) {
          return Reflect.set(target, prop, value, receiver);
        }

        const builder = new Builder(1024);
        const data = { width: (prop === 'width') ? value : target.fbb.width(), height: (prop === 'height') ? value : target.fbb.height(), format: (prop === 'format') ? value : target.fbb.format(), createdAt: (prop === 'createdAt') ? value : target.fbb.created_at() };
        
    const formatOffset = data.format ? builder.createString(data.format) : 0;
        
        const entityOffset = Image_MetadataFB.Image_Metadata.createImage_Metadata(builder, data.width, data.height, formatOffset, data.createdAt);
        builder.finish(entityOffset);
        const buffer = builder.asUint8Array();

        target.db.update(
          'Image_Metadata',
          target.id,
          buffer
        );
        
        const newFbb = Image_MetadataFB.Image_Metadata.getRootAsImage_Metadata(new ByteBuffer(buffer));
        target.fbb = newFbb;

        return true;
      }
    });
  }

  // --- Fields ---
  get width(): bigint {
    return this.fbb.width();
  }

  get height(): bigint {
    return this.fbb.height();
  }

  get format(): string | null {
    return this.fbb.format();
  }

  get createdAt(): bigint {
    return this.fbb.created_at();
  }

  // --- Relationships ---

}

export class ImageNode<TActor> extends ZgBaseNode<ImageFB.Image, TActor> {
  constructor(
    db: ZgDatabase,
    fbb: ImageFB.Image,
    authContext: ZgAuthContext<TActor> | null
  ) {
    super(db, fbb, authContext);
    
    return new Proxy(this, {
      get: (target, prop, receiver) => {
        const entityResolvers = target.db.config.entityResolvers?.['Image'] ?? {};
        if (prop in entityResolvers) {
          return entityResolvers[prop as keyof typeof entityResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        const globalResolvers = target.db.config.globalResolvers ?? {};
        if (prop in globalResolvers) {
          return globalResolvers[prop as keyof typeof globalResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        return Reflect.get(target, prop, receiver);
      },
      set: (target, prop, value, receiver) => {
        const schemaFields = new Set(['id', 'url', 'fartCount', 'altText', 'metadata', 'postId', 'userId']);
        if (!schemaFields.has(prop as string)) {
          return Reflect.set(target, prop, value, receiver);
        }

        const builder = new Builder(1024);
        const data = { id: (prop === 'id') ? value : target.fbb.id(), url: (prop === 'url') ? value : target.fbb.url(), fartCount: (prop === 'fartCount') ? value : target.fbb.fart_count(), altText: (prop === 'altText') ? value : target.fbb.alt_text(), metadata: (prop === 'metadata') ? value : target.fbb.metadata(), postId: (prop === 'postId') ? value : target.fbb.post_id(), userId: (prop === 'userId') ? value : target.fbb.user_id() };
        
    const idOffset = data.id ? builder.createString(data.id) : 0;
    const urlOffset = data.url ? builder.createString(data.url) : 0;
    const altTextOffset = data.altText ? builder.createString(data.altText) : 0;
    const postIdOffset = data.postId ? builder.createString(data.postId) : 0;
    const userIdOffset = data.userId ? builder.createString(data.userId) : 0;
        
        const entityOffset = ImageFB.Image.createImage(builder, idOffset, urlOffset, data.fartCount, altTextOffset, data.metadata, postIdOffset, userIdOffset);
        builder.finish(entityOffset);
        const buffer = builder.asUint8Array();

        target.db.update(
          'Image',
          target.id,
          buffer
        );
        
        const newFbb = ImageFB.Image.getRootAsImage(new ByteBuffer(buffer));
        target.fbb = newFbb;

        return true;
      }
    });
  }

  // --- Fields ---
  get id(): string | null {
    return this.fbb.id();
  }

  get url(): string | null {
    return this.fbb.url();
  }

  get fartCount(): bigint {
    return this.fbb.fart_count();
  }

  get altText(): string | null {
    return this.fbb.alt_text();
  }

  get metadata(): any {
    return this.fbb.metadata();
  }

  get postId(): string | null {
    return this.fbb.post_id();
  }

  get userId(): string | null {
    return this.fbb.user_id();
  }

  // --- Relationships ---
  get post(): PostNode<TActor> | null {
    const id = this.fbb.post_id();
    if (!id) return null;
    return this.db.get(
      'Post',
       id,
       (db, fbb, ac) => new PostNode<TActor>(db, fbb, ac),
       (bb) => PostFB.Post.getRootAsPost(bb),
       this.authContext
    ) as PostNode<TActor> | null;
  }

  get user(): UserNode<TActor> | null {
    const id = this.fbb.user_id();
    if (!id) return null;
    return this.db.get(
      'User',
       id,
       (db, fbb, ac) => new UserNode<TActor>(db, fbb, ac),
       (bb) => UserFB.User.getRootAsUser(bb),
       this.authContext
    ) as UserNode<TActor> | null;
  }
}

export class ReactionNode<TActor> extends ZgBaseNode<ReactionFB.Reaction, TActor> {
  constructor(
    db: ZgDatabase,
    fbb: ReactionFB.Reaction,
    authContext: ZgAuthContext<TActor> | null
  ) {
    super(db, fbb, authContext);
    
    return new Proxy(this, {
      get: (target, prop, receiver) => {
        const entityResolvers = target.db.config.entityResolvers?.['Reaction'] ?? {};
        if (prop in entityResolvers) {
          return entityResolvers[prop as keyof typeof entityResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        const globalResolvers = target.db.config.globalResolvers ?? {};
        if (prop in globalResolvers) {
          return globalResolvers[prop as keyof typeof globalResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        return Reflect.get(target, prop, receiver);
      },
      set: (target, prop, value, receiver) => {
        const schemaFields = new Set(['id', 'type', 'authorId', 'targetId', 'targetType']);
        if (!schemaFields.has(prop as string)) {
          return Reflect.set(target, prop, value, receiver);
        }

        const builder = new Builder(1024);
        const data = { id: (prop === 'id') ? value : target.fbb.id(), type: (prop === 'type') ? value : target.fbb.type(), authorId: (prop === 'authorId') ? value : target.fbb.author_id(), targetId: (prop === 'targetId') ? value : target.fbb.target_id(), targetType: (prop === 'targetType') ? value : target.fbb.target_type() };
        
    const idOffset = data.id ? builder.createString(data.id) : 0;
    const typeOffset = data.type ? builder.createString(data.type) : 0;
    const authorIdOffset = data.authorId ? builder.createString(data.authorId) : 0;
    const targetIdOffset = data.targetId ? builder.createString(data.targetId) : 0;
    const targetTypeOffset = data.targetType ? builder.createString(data.targetType) : 0;
        
        const entityOffset = ReactionFB.Reaction.createReaction(builder, idOffset, typeOffset, authorIdOffset, targetIdOffset, targetTypeOffset);
        builder.finish(entityOffset);
        const buffer = builder.asUint8Array();

        target.db.update(
          'Reaction',
          target.id,
          buffer
        );
        
        const newFbb = ReactionFB.Reaction.getRootAsReaction(new ByteBuffer(buffer));
        target.fbb = newFbb;

        return true;
      }
    });
  }

  // --- Fields ---
  get id(): string | null {
    return this.fbb.id();
  }

  get type(): string | null {
    return this.fbb.type();
  }

  get authorId(): string | null {
    return this.fbb.author_id();
  }

  get targetId(): string | null {
    return this.fbb.target_id();
  }

  get targetType(): string | null {
    return this.fbb.target_type();
  }

  // --- Relationships ---
  get author(): UserNode<TActor> | null {
    const id = this.fbb.author_id();
    if (!id) return null;
    return this.db.get(
      'User',
       id,
       (db, fbb, ac) => new UserNode<TActor>(db, fbb, ac),
       (bb) => UserFB.User.getRootAsUser(bb),
       this.authContext
    ) as UserNode<TActor> | null;
  }
}

export class TagNode<TActor> extends ZgBaseNode<TagFB.Tag, TActor> {
  constructor(
    db: ZgDatabase,
    fbb: TagFB.Tag,
    authContext: ZgAuthContext<TActor> | null
  ) {
    super(db, fbb, authContext);
    
    return new Proxy(this, {
      get: (target, prop, receiver) => {
        const entityResolvers = target.db.config.entityResolvers?.['Tag'] ?? {};
        if (prop in entityResolvers) {
          return entityResolvers[prop as keyof typeof entityResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        const globalResolvers = target.db.config.globalResolvers ?? {};
        if (prop in globalResolvers) {
          return globalResolvers[prop as keyof typeof globalResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        return Reflect.get(target, prop, receiver);
      },
      set: (target, prop, value, receiver) => {
        const schemaFields = new Set(['id', 'name']);
        if (!schemaFields.has(prop as string)) {
          return Reflect.set(target, prop, value, receiver);
        }

        const builder = new Builder(1024);
        const data = { id: (prop === 'id') ? value : target.fbb.id(), name: (prop === 'name') ? value : target.fbb.name() };
        
    const idOffset = data.id ? builder.createString(data.id) : 0;
    const nameOffset = data.name ? builder.createString(data.name) : 0;
        
        const entityOffset = TagFB.Tag.createTag(builder, idOffset, nameOffset);
        builder.finish(entityOffset);
        const buffer = builder.asUint8Array();

        target.db.update(
          'Tag',
          target.id,
          buffer
        );
        
        const newFbb = TagFB.Tag.getRootAsTag(new ByteBuffer(buffer));
        target.fbb = newFbb;

        return true;
      }
    });
  }

  // --- Fields ---
  get id(): string | null {
    return this.fbb.id();
  }

  get name(): string | null {
    return this.fbb.name();
  }

  // --- Relationships ---

}

export class PostTagNode<TActor> extends ZgBaseNode<PostTagFB.PostTag, TActor> {
  constructor(
    db: ZgDatabase,
    fbb: PostTagFB.PostTag,
    authContext: ZgAuthContext<TActor> | null
  ) {
    super(db, fbb, authContext);
    
    return new Proxy(this, {
      get: (target, prop, receiver) => {
        const entityResolvers = target.db.config.entityResolvers?.['PostTag'] ?? {};
        if (prop in entityResolvers) {
          return entityResolvers[prop as keyof typeof entityResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        const globalResolvers = target.db.config.globalResolvers ?? {};
        if (prop in globalResolvers) {
          return globalResolvers[prop as keyof typeof globalResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        return Reflect.get(target, prop, receiver);
      },
      set: (target, prop, value, receiver) => {
        const schemaFields = new Set(['id', 'postId', 'tagId']);
        if (!schemaFields.has(prop as string)) {
          return Reflect.set(target, prop, value, receiver);
        }

        const builder = new Builder(1024);
        const data = { id: (prop === 'id') ? value : target.fbb.id(), postId: (prop === 'postId') ? value : target.fbb.post_id(), tagId: (prop === 'tagId') ? value : target.fbb.tag_id() };
        
    const idOffset = data.id ? builder.createString(data.id) : 0;
    const postIdOffset = data.postId ? builder.createString(data.postId) : 0;
    const tagIdOffset = data.tagId ? builder.createString(data.tagId) : 0;
        
        const entityOffset = PostTagFB.PostTag.createPostTag(builder, idOffset, postIdOffset, tagIdOffset);
        builder.finish(entityOffset);
        const buffer = builder.asUint8Array();

        target.db.update(
          'PostTag',
          target.id,
          buffer
        );
        
        const newFbb = PostTagFB.PostTag.getRootAsPostTag(new ByteBuffer(buffer));
        target.fbb = newFbb;

        return true;
      }
    });
  }

  // --- Fields ---
  get id(): string | null {
    return this.fbb.id();
  }

  get postId(): string | null {
    return this.fbb.post_id();
  }

  get tagId(): string | null {
    return this.fbb.tag_id();
  }

  // --- Relationships ---
  get post(): PostNode<TActor> | null {
    const id = this.fbb.post_id();
    if (!id) return null;
    return this.db.get(
      'Post',
       id,
       (db, fbb, ac) => new PostNode<TActor>(db, fbb, ac),
       (bb) => PostFB.Post.getRootAsPost(bb),
       this.authContext
    ) as PostNode<TActor> | null;
  }

  get tag(): TagNode<TActor> | null {
    const id = this.fbb.tag_id();
    if (!id) return null;
    return this.db.get(
      'Tag',
       id,
       (db, fbb, ac) => new TagNode<TActor>(db, fbb, ac),
       (bb) => TagFB.Tag.getRootAsTag(bb),
       this.authContext
    ) as TagNode<TActor> | null;
  }
}

// --- Collection Classes ---

export class UserCollection<TActor> extends EntityCollection<UserNode<TActor>> {

  create(data: UserCreateInput): UserNode<TActor> {
    const builder = new Builder(1024);
    
    const idOffset = data.id ? builder.createString(data.id) : 0;
    const publicKeyOffset = data.publicKey ? builder.createString(data.publicKey) : 0;
    const displayNameOffset = data.displayName ? builder.createString(data.displayName) : 0;
    const avatarUrlOffset = data.avatarUrl ? builder.createString(data.avatarUrl) : 0;
    
    const entityOffset = UserFB.User.createUser(builder, idOffset, publicKeyOffset, displayNameOffset, avatarUrlOffset);
    builder.finish(entityOffset);
    
    const buffer = builder.asUint8Array();
    
    if (!data.id || typeof data.id !== 'string') {
      throw new Error("The 'id' field is required and must be a string to create an entity.");
    }

    return this.db.create(
      'User',
      data.id,
      buffer,
      this.nodeFactory,
      this.getRootAs,
      this.authContext,
    );
  }
}



export class PostCollection<TActor> extends EntityCollection<PostNode<TActor>> {

  create(data: PostCreateInput): PostNode<TActor> {
    const builder = new Builder(1024);
    
    const idOffset = data.id ? builder.createString(data.id) : 0;
    const titleOffset = data.title ? builder.createString(data.title) : 0;
    const contentOffset = data.content ? builder.createString(data.content) : 0;
    const authorIdOffset = data.authorId ? builder.createString(data.authorId) : 0;
    
    const entityOffset = PostFB.Post.createPost(builder, idOffset, titleOffset, contentOffset, authorIdOffset, BigInt(data.createdAt ?? 0));
    builder.finish(entityOffset);
    
    const buffer = builder.asUint8Array();
    
    if (!data.id || typeof data.id !== 'string') {
      throw new Error("The 'id' field is required and must be a string to create an entity.");
    }

    return this.db.create(
      'Post',
      data.id,
      buffer,
      this.nodeFactory,
      this.getRootAs,
      this.authContext,
    );
  }
}



export class CommentCollection<TActor> extends EntityCollection<CommentNode<TActor>> {

  create(data: CommentCreateInput): CommentNode<TActor> {
    const builder = new Builder(1024);
    
    const idOffset = data.id ? builder.createString(data.id) : 0;
    const contentOffset = data.content ? builder.createString(data.content) : 0;
    const authorIdOffset = data.authorId ? builder.createString(data.authorId) : 0;
    const postIdOffset = data.postId ? builder.createString(data.postId) : 0;
    
    const entityOffset = CommentFB.Comment.createComment(builder, idOffset, contentOffset, authorIdOffset, postIdOffset, BigInt(data.createdAt ?? 0));
    builder.finish(entityOffset);
    
    const buffer = builder.asUint8Array();
    
    if (!data.id || typeof data.id !== 'string') {
      throw new Error("The 'id' field is required and must be a string to create an entity.");
    }

    return this.db.create(
      'Comment',
      data.id,
      buffer,
      this.nodeFactory,
      this.getRootAs,
      this.authContext,
    );
  }
}



export class FollowCollection<TActor> extends EntityCollection<FollowNode<TActor>> {

  create(data: FollowCreateInput): FollowNode<TActor> {
    const builder = new Builder(1024);
    
    const idOffset = data.id ? builder.createString(data.id) : 0;
    const followerIdOffset = data.followerId ? builder.createString(data.followerId) : 0;
    const followingIdOffset = data.followingId ? builder.createString(data.followingId) : 0;
    
    const entityOffset = FollowFB.Follow.createFollow(builder, idOffset, followerIdOffset, followingIdOffset, BigInt(data.createdAt ?? 0));
    builder.finish(entityOffset);
    
    const buffer = builder.asUint8Array();
    
    if (!data.id || typeof data.id !== 'string') {
      throw new Error("The 'id' field is required and must be a string to create an entity.");
    }

    return this.db.create(
      'Follow',
      data.id,
      buffer,
      this.nodeFactory,
      this.getRootAs,
      this.authContext,
    );
  }
}



export class Image_MetadataCollection<TActor> extends EntityCollection<Image_MetadataNode<TActor>> {

  create(data: Image_MetadataCreateInput): Image_MetadataNode<TActor> {
    const builder = new Builder(1024);
    
    const formatOffset = data.format ? builder.createString(data.format) : 0;
    
    const entityOffset = Image_MetadataFB.Image_Metadata.createImage_Metadata(builder, BigInt(data.width ?? 0), BigInt(data.height ?? 0), formatOffset, BigInt(data.createdAt ?? 0));
    builder.finish(entityOffset);
    
    const buffer = builder.asUint8Array();
    
    if (!data.id || typeof data.id !== 'string') {
      throw new Error("The 'id' field is required and must be a string to create an entity.");
    }

    return this.db.create(
      'Image_Metadata',
      data.id,
      buffer,
      this.nodeFactory,
      this.getRootAs,
      this.authContext,
    );
  }
}



export class ImageCollection<TActor> extends EntityCollection<ImageNode<TActor>> {

  create(data: ImageCreateInput): ImageNode<TActor> {
    const builder = new Builder(1024);
    
    const idOffset = data.id ? builder.createString(data.id) : 0;
    const urlOffset = data.url ? builder.createString(data.url) : 0;
    const altTextOffset = data.altText ? builder.createString(data.altText) : 0;
    const postIdOffset = data.postId ? builder.createString(data.postId) : 0;
    const userIdOffset = data.userId ? builder.createString(data.userId) : 0;
    
    const entityOffset = ImageFB.Image.createImage(builder, idOffset, urlOffset, BigInt(data.fartCount ?? 0), altTextOffset, data.metadata, postIdOffset, userIdOffset);
    builder.finish(entityOffset);
    
    const buffer = builder.asUint8Array();
    
    if (!data.id || typeof data.id !== 'string') {
      throw new Error("The 'id' field is required and must be a string to create an entity.");
    }

    return this.db.create(
      'Image',
      data.id,
      buffer,
      this.nodeFactory,
      this.getRootAs,
      this.authContext,
    );
  }
}



export class ReactionCollection<TActor> extends EntityCollection<ReactionNode<TActor>> {

  create(data: ReactionCreateInput): ReactionNode<TActor> {
    const builder = new Builder(1024);
    
    const idOffset = data.id ? builder.createString(data.id) : 0;
    const typeOffset = data.type ? builder.createString(data.type) : 0;
    const authorIdOffset = data.authorId ? builder.createString(data.authorId) : 0;
    const targetIdOffset = data.targetId ? builder.createString(data.targetId) : 0;
    const targetTypeOffset = data.targetType ? builder.createString(data.targetType) : 0;
    
    const entityOffset = ReactionFB.Reaction.createReaction(builder, idOffset, typeOffset, authorIdOffset, targetIdOffset, targetTypeOffset);
    builder.finish(entityOffset);
    
    const buffer = builder.asUint8Array();
    
    if (!data.id || typeof data.id !== 'string') {
      throw new Error("The 'id' field is required and must be a string to create an entity.");
    }

    return this.db.create(
      'Reaction',
      data.id,
      buffer,
      this.nodeFactory,
      this.getRootAs,
      this.authContext,
    );
  }
}



export class TagCollection<TActor> extends EntityCollection<TagNode<TActor>> {

  create(data: TagCreateInput): TagNode<TActor> {
    const builder = new Builder(1024);
    
    const idOffset = data.id ? builder.createString(data.id) : 0;
    const nameOffset = data.name ? builder.createString(data.name) : 0;
    
    const entityOffset = TagFB.Tag.createTag(builder, idOffset, nameOffset);
    builder.finish(entityOffset);
    
    const buffer = builder.asUint8Array();
    
    if (!data.id || typeof data.id !== 'string') {
      throw new Error("The 'id' field is required and must be a string to create an entity.");
    }

    return this.db.create(
      'Tag',
      data.id,
      buffer,
      this.nodeFactory,
      this.getRootAs,
      this.authContext,
    );
  }
}



export class PostTagCollection<TActor> extends EntityCollection<PostTagNode<TActor>> {

  create(data: PostTagCreateInput): PostTagNode<TActor> {
    const builder = new Builder(1024);
    
    const idOffset = data.id ? builder.createString(data.id) : 0;
    const postIdOffset = data.postId ? builder.createString(data.postId) : 0;
    const tagIdOffset = data.tagId ? builder.createString(data.tagId) : 0;
    
    const entityOffset = PostTagFB.PostTag.createPostTag(builder, idOffset, postIdOffset, tagIdOffset);
    builder.finish(entityOffset);
    
    const buffer = builder.asUint8Array();
    
    if (!data.id || typeof data.id !== 'string') {
      throw new Error("The 'id' field is required and must be a string to create an entity.");
    }

    return this.db.create(
      'PostTag',
      data.id,
      buffer,
      this.nodeFactory,
      this.getRootAs,
      this.authContext,
    );
  }
}


export class ZgClient<TActor> extends ZgDatabase {
  public readonly users: UserCollection<TActor>;
  public readonly posts: PostCollection<TActor>;
  public readonly comments: CommentCollection<TActor>;
  public readonly follows: FollowCollection<TActor>;
  public readonly image_Metadatas: Image_MetadataCollection<TActor>;
  public readonly images: ImageCollection<TActor>;
  public readonly reactions: ReactionCollection<TActor>;
  public readonly tags: TagCollection<TActor>;
  public readonly postTags: PostTagCollection<TActor>;
  constructor(
    prollyTree: ProllyTree,
    config: ZgConfig<TActor> = { entityResolvers: {}, globalResolvers: {} },
    authContext: ZgAuthContext<TActor> | null = null,
  ) {
    super(prollyTree, config, authContext);
    this.users = new UserCollection<TActor>(this, this.authContext);
    this.posts = new PostCollection<TActor>(this, this.authContext);
    this.comments = new CommentCollection<TActor>(this, this.authContext);
    this.follows = new FollowCollection<TActor>(this, this.authContext);
    this.image_Metadatas = new Image_MetadataCollection<TActor>(this, this.authContext);
    this.images = new ImageCollection<TActor>(this, this.authContext);
    this.reactions = new ReactionCollection<TActor>(this, this.authContext);
    this.tags = new TagCollection<TActor>(this, this.authContext);
    this.postTags = new PostTagCollection<TActor>(this, this.authContext);
  }

  public with<TActor>(actor: TActor): ZgClient<TActor> {
    return new ZgClient<TActor>(this.prollyTree, this.config, { actor });
  }
}