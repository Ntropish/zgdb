// @generated
// Automatically generated. Don't change this file manually.
// Name: schema.ts


// @ts-nocheck
// This file is generated by @zgdb/zg. Do not edit it manually.
// TODO: Generate based on the user's config
import { ZgDatabase, ZgBaseNode, ZgAuthContext, EntityCollection } from '@zgdb/client';
import { Builder, ByteBuffer } from 'flatbuffers';
import * as TestEntityFB from './schema/test-entity.js';


// --- Interfaces ---
export interface ITestEntity {
  id: string;
  value: bigint;
}

// --- Create Input Types ---
export type TestEntityCreateInput = { id: string, value: bigint };

// --- Node Classes ---
export class TestEntityNode<TActor> extends ZgBaseNode<TestEntityFB.TestEntity, TActor> {
  constructor(
    db: ZgDatabase,
    fbb: TestEntityFB.TestEntity,
    authContext: ZgAuthContext<TActor> | null
  ) {
    super(db, fbb, authContext);
    
    return new Proxy(this, {
      get: (target, prop, receiver) => {
        const entityResolvers = target.db.config.entityResolvers?.['TestEntity'] ?? {};
        if (prop in entityResolvers) {
          return entityResolvers[prop as keyof typeof entityResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        const globalResolvers = target.db.config.globalResolvers ?? {};
        if (prop in globalResolvers) {
          return globalResolvers[prop as keyof typeof globalResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        return Reflect.get(target, prop, receiver);
      },
      set: (target, prop, value, receiver) => {
        const schemaFields = new Set(['id', 'value']);
        if (!schemaFields.has(prop as string)) {
          return Reflect.set(target, prop, value, receiver);
        }

        const builder = new Builder(1024);
        const data = { id: (prop === 'id') ? value : target.fbb.id(), value: (prop === 'value') ? value : target.fbb.value() };
        
    const idOffset = data.id ? builder.createString(data.id) : 0;
        
        const entityOffset = TestEntityFB.TestEntity.createTestEntity(builder, idOffset, data.value);
        builder.finish(entityOffset);
        const buffer = builder.asUint8Array();

        target.db.update(
          'TestEntity',
          target.id,
          buffer
        );
        
        const newFbb = TestEntityFB.TestEntity.getRootAsTestEntity(new ByteBuffer(buffer));
        target.fbb = newFbb;

        return true;
      }
    });
  }

  // --- Fields ---
  get id(): string | null {
    return this.fbb.id();
  }

  get value(): bigint {
    return this.fbb.value();
  }

  // --- Relationships ---

}

// --- Collection Classes ---

export class TestEntityCollection<TActor> extends EntityCollection<TestEntityNode<TActor>> {

  create(data: TestEntityCreateInput): TestEntityNode<TActor> {
    const builder = new Builder(1024);
    
    const idOffset = data.id ? builder.createString(data.id) : 0;
    
    const entityOffset = TestEntityFB.TestEntity.createTestEntity(builder, idOffset, BigInt(data.value ?? 0));
    builder.finish(entityOffset);
    
    const buffer = builder.asUint8Array();
    
    if (!data.id || typeof data.id !== 'string') {
      throw new Error("The 'id' field is required and must be a string to create an entity.");
    }

    return this.db.create(
      'TestEntity',
      data.id,
      buffer,
      this.nodeFactory,
      this.getRootAs,
      this.authContext,
    );
  }
}


export class ZgClient<TActor> extends ZgDatabase {
  public readonly testEntitys: TestEntityCollection<TActor>;
  constructor(
    prollyTree: ProllyTree,
    config: ZgConfig<TActor> = { entityResolvers: {}, globalResolvers: {} },
    authContext: ZgAuthContext<TActor> | null = null,
  ) {
    super(prollyTree, config, authContext);
    this.testEntitys = new TestEntityCollection<TActor>(this, this.authContext);
  }

  public with<TActor>(actor: TActor): ZgClient<TActor> {
    return new ZgClient<TActor>(this.prollyTree, this.config, { actor });
  }
}