// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`ZgFileGenerator > should generate a complete schema file from all sub-generators 1`] = `
"// @generated
// Automatically generated. Don't change this file manually.
// Name: schema.ts


// @ts-nocheck
// This file is generated by @zgdb/zg. Do not edit it manually.
// TODO: Generate based on the user's config
import { ZgDatabase, ZgBaseNode, ZgAuthContext, EntityCollection } from '@zgdb/client';
import { Builder, ByteBuffer } from 'flatbuffers';
import * as UserFB from './schema/user.js';
import * as PostFB from './schema/post.js';


// --- Interfaces ---
export interface IUser {
  id: any;
  name: string;
}

export interface IPost {
  id: any;
  title: string;
  authorId: any;
}

// --- Create Input Types ---
export type UserCreateInput = { id: any, name: string };
export type PostCreateInput = { id: any, title: string, authorId: any };

// --- Node Classes ---
export class UserNode<TActor> extends ZgBaseNode<UserFB.User, TActor> {
  constructor(
    db: ZgDatabase,
    fbb: UserFB.User,
    authContext: ZgAuthContext<TActor> | null
  ) {
    super(db, fbb, authContext);
    
    return new Proxy(this, {
      get: (target, prop, receiver) => {
        const entityResolvers = target.db.config.entityResolvers?.['User'] ?? {};
        if (prop in entityResolvers) {
          return entityResolvers[prop as keyof typeof entityResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        const globalResolvers = target.db.config.globalResolvers ?? {};
        if (prop in globalResolvers) {
          return globalResolvers[prop as keyof typeof globalResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        return Reflect.get(target, prop, receiver);
      },
      set: (target, prop, value, receiver) => {
        const schemaFields = new Set(['id', 'name']);
        if (!schemaFields.has(prop as string)) {
          return Reflect.set(target, prop, value, receiver);
        }

        const builder = new Builder(1024);
        const data = { id: (prop === 'id') ? value : target.fbb.id(), name: (prop === 'name') ? value : target.fbb.name() };
        
    const nameOffset = data.name ? builder.createString(data.name) : 0;
        
        const entityOffset = UserFB.User.createUser(builder, data.id, nameOffset);
        builder.finish(entityOffset);
        const buffer = builder.asUint8Array();

        target.db.update(
          'User',
          target.id,
          buffer
        );
        
        const newFbb = UserFB.User.getRootAsUser(new ByteBuffer(buffer));
        target.fbb = newFbb;

        return true;
      }
    });
  }

  // --- Fields ---
  get id(): any {
    return this.fbb.id();
  }

  get name(): string | null {
    return this.fbb.name();
  }

  // --- Relationships ---

}

export class PostNode<TActor> extends ZgBaseNode<PostFB.Post, TActor> {
  constructor(
    db: ZgDatabase,
    fbb: PostFB.Post,
    authContext: ZgAuthContext<TActor> | null
  ) {
    super(db, fbb, authContext);
    
    return new Proxy(this, {
      get: (target, prop, receiver) => {
        const entityResolvers = target.db.config.entityResolvers?.['Post'] ?? {};
        if (prop in entityResolvers) {
          return entityResolvers[prop as keyof typeof entityResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        const globalResolvers = target.db.config.globalResolvers ?? {};
        if (prop in globalResolvers) {
          return globalResolvers[prop as keyof typeof globalResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        return Reflect.get(target, prop, receiver);
      },
      set: (target, prop, value, receiver) => {
        const schemaFields = new Set(['id', 'title', 'authorId']);
        if (!schemaFields.has(prop as string)) {
          return Reflect.set(target, prop, value, receiver);
        }

        const builder = new Builder(1024);
        const data = { id: (prop === 'id') ? value : target.fbb.id(), title: (prop === 'title') ? value : target.fbb.title(), authorId: (prop === 'authorId') ? value : target.fbb.author_id() };
        
    const titleOffset = data.title ? builder.createString(data.title) : 0;
        
        const entityOffset = PostFB.Post.createPost(builder, data.id, titleOffset, data.authorId);
        builder.finish(entityOffset);
        const buffer = builder.asUint8Array();

        target.db.update(
          'Post',
          target.id,
          buffer
        );
        
        const newFbb = PostFB.Post.getRootAsPost(new ByteBuffer(buffer));
        target.fbb = newFbb;

        return true;
      }
    });
  }

  // --- Fields ---
  get id(): any {
    return this.fbb.id();
  }

  get title(): string | null {
    return this.fbb.title();
  }

  get authorId(): any {
    return this.fbb.author_id();
  }

  // --- Relationships ---

}

// --- Collection Classes ---

export class UserCollection<TActor> extends EntityCollection<UserNode<TActor>> {

  create(data: UserCreateInput): UserNode<TActor> {
    const builder = new Builder(1024);
    
    const nameOffset = data.name ? builder.createString(data.name) : 0;
    
    const entityOffset = UserFB.User.createUser(builder, data.id, nameOffset);
    builder.finish(entityOffset);
    
    const buffer = builder.asUint8Array();
    
    if (!data.id || typeof data.id !== 'string') {
      throw new Error("The 'id' field is required and must be a string to create an entity.");
    }

    return this.db.create(
      'User',
      data.id,
      buffer,
      this.nodeFactory,
      this.getRootAs,
      this.authContext,
    );
  }
}



export class PostCollection<TActor> extends EntityCollection<PostNode<TActor>> {

  create(data: PostCreateInput): PostNode<TActor> {
    const builder = new Builder(1024);
    
    const titleOffset = data.title ? builder.createString(data.title) : 0;
    
    const entityOffset = PostFB.Post.createPost(builder, data.id, titleOffset, data.authorId);
    builder.finish(entityOffset);
    
    const buffer = builder.asUint8Array();
    
    if (!data.id || typeof data.id !== 'string') {
      throw new Error("The 'id' field is required and must be a string to create an entity.");
    }

    return this.db.create(
      'Post',
      data.id,
      buffer,
      this.nodeFactory,
      this.getRootAs,
      this.authContext,
    );
  }
}


export class ZgClient<TActor> extends ZgDatabase {
  public readonly users: UserCollection<TActor>;
  public readonly posts: PostCollection<TActor>;
  constructor(
    prollyTree: ProllyTree,
    config: ZgConfig<TActor> = { entityResolvers: {}, globalResolvers: {} },
    authContext: ZgAuthContext<TActor> | null = null,
  ) {
    super(prollyTree, config, authContext);
    this.users = new UserCollection<TActor>(this, this.authContext);
    this.posts = new PostCollection<TActor>(this, this.authContext);
  }

  public with<TActor>(actor: TActor): ZgClient<TActor> {
    return new ZgClient<TActor>(this.prollyTree, this.config, { actor });
  }
}"
`;
