// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`ZgFileGenerator > should generate a complete schema file from all sub-generators 1`] = `
"// @generated
// Automatically generated. Don't change this file manually.
// Name: schema.ts


// @ts-nocheck
// This file is generated by @zgdb/zg. Do not edit it manually.
// TODO: Generate based on the user's config
import { ZgDatabase, ZgBaseNode, ZgAuthContext, EntityCollection } from '@zgdb/client';
import { Builder, ByteBuffer } from 'flatbuffers';
import * as UserFB from './schema/user.js';
import * as PostFB from './schema/post.js';


// --- Interfaces ---
export interface IUser {
  id: any;
  name: string;
}

export interface IPost {
  id: any;
  title: string;
  authorId: any;
}

// --- Create Input Types ---
export type CreateUserInput = { name: string };
export type CreatePostInput = { title: string, authorId: any };

// --- Node Classes ---
export class UserNode<TActor> extends ZgBaseNode<UserFB.User, TActor> {
  constructor(
    db: ZgDatabase,
    fbb: UserFB.User,
    authContext: ZgAuthContext<TActor> | null
  ) {
    super(db, fbb, authContext);
    
    return new Proxy(this, {
      get: (target, prop, receiver) => {
        const entityResolvers = target.db.config.entityResolvers?.['User'] ?? {};
        if (prop in entityResolvers) {
          return entityResolvers[prop as keyof typeof entityResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        const globalResolvers = target.db.config.globalResolvers ?? {};
        if (prop in globalResolvers) {
          return globalResolvers[prop as keyof typeof globalResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        return Reflect.get(target, prop, receiver);
      },
      set: (target, prop, value, receiver) => {
        const schemaFields = new Set(['id', 'name']);
        if (!schemaFields.has(prop as string)) {
          return Reflect.set(target, prop, value, receiver);
        }

        const builder = new Builder(1024);
        const data = { id: (prop === 'id') ? value : target.fbb.id(), name: (prop === 'name') ? value : target.fbb.name() };
        
    const nameOffset = data.name ? builder.createString(data.name) : 0;
        
        const entityOffset = UserFB.User.createUser(builder, data.id, nameOffset);
        builder.finish(entityOffset);
        const buffer = builder.asUint8Array();

        target.db.update(
          'User',
          target.id,
          buffer
        );
        
        const newFbb = UserFB.User.getRootAsUser(new ByteBuffer(buffer));
        target.fbb = newFbb;

        return true;
      }
    });
  }

  // --- Fields ---
  get id(): any {
    return this.fbb.id();
  }

  get name(): string | null {
    return this.fbb.name();
  }

  // --- Relationships ---

}

export class PostNode<TActor> extends ZgBaseNode<PostFB.Post, TActor> {
  constructor(
    db: ZgDatabase,
    fbb: PostFB.Post,
    authContext: ZgAuthContext<TActor> | null
  ) {
    super(db, fbb, authContext);
    
    return new Proxy(this, {
      get: (target, prop, receiver) => {
        const entityResolvers = target.db.config.entityResolvers?.['Post'] ?? {};
        if (prop in entityResolvers) {
          return entityResolvers[prop as keyof typeof entityResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        const globalResolvers = target.db.config.globalResolvers ?? {};
        if (prop in globalResolvers) {
          return globalResolvers[prop as keyof typeof globalResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        return Reflect.get(target, prop, receiver);
      },
      set: (target, prop, value, receiver) => {
        const schemaFields = new Set(['id', 'title', 'authorId']);
        if (!schemaFields.has(prop as string)) {
          return Reflect.set(target, prop, value, receiver);
        }

        const builder = new Builder(1024);
        const data = { authorId: (prop === 'authorId') ? value : target.fbb.authorId(), id: (prop === 'id') ? value : target.fbb.id(), title: (prop === 'title') ? value : target.fbb.title() };
        
    const titleOffset = data.title ? builder.createString(data.title) : 0;
        
        const entityOffset = PostFB.Post.createPost(builder, data.authorId, data.id, titleOffset);
        builder.finish(entityOffset);
        const buffer = builder.asUint8Array();

        target.db.update(
          'Post',
          target.id,
          buffer
        );
        
        const newFbb = PostFB.Post.getRootAsPost(new ByteBuffer(buffer));
        target.fbb = newFbb;

        return true;
      }
    });
  }

  // --- Fields ---
  get id(): any {
    return this.fbb.id();
  }

  get title(): string | null {
    return this.fbb.title();
  }

  get authorId(): any {
    return this.fbb.authorId();
  }

  // --- Relationships ---

}

// --- Collection Classes ---
export class UserCollection<TActor> {
    constructor(
      private db: ZgDatabase,
      private authContext: ZgAuthContext<TActor> | null
    ) {}

    get collectionName(): string {
      return 'User';
    }

    create(data: CreateUserInput): UserNode<TActor> {
      const builder = new Builder(1024);
      
          const nameOffset = data.name ? builder.createString(data.name) : 0;
      

      UserFB.User.startUser(builder);
      
      UserFB.User.addId(builder, data.id ?? null);
    UserFB.User.addName(builder, nameOffset ?? 0);

      const entityOffset = UserFB.User.endUser(builder);
      
      builder.finish(entityOffset);
      const buffer = builder.asUint8Array();

      this.db.insert(this.collectionName, data.id, buffer);

      const fbb = UserFB.User.getRootAsUser(new ByteBuffer(buffer));

      return new UserNode<TActor>(
        this.db,
        fbb,
        this.authContext,
      );
    }

    *[Symbol.iterator](): Generator<UserNode<TActor>> {
      for (const [id, buffer] of this.db.scan(this.collectionName)) {
        const fbb = UserFB.User.getRootAsUser(new ByteBuffer(buffer));
        yield new UserNode<TActor>(
          this.db,
          fbb,
          this.authContext,
        );
      }
    }
  }

export class PostCollection<TActor> {
    constructor(
      private db: ZgDatabase,
      private authContext: ZgAuthContext<TActor> | null
    ) {}

    get collectionName(): string {
      return 'Post';
    }

    create(data: CreatePostInput): PostNode<TActor> {
      const builder = new Builder(1024);
      
          const titleOffset = data.title ? builder.createString(data.title) : 0;
      

      PostFB.Post.startPost(builder);
      
      PostFB.Post.addAuthorId(builder, data.authorId ?? null);
    PostFB.Post.addId(builder, data.id ?? null);
    PostFB.Post.addTitle(builder, titleOffset ?? 0);

      const entityOffset = PostFB.Post.endPost(builder);
      
      builder.finish(entityOffset);
      const buffer = builder.asUint8Array();

      this.db.insert(this.collectionName, data.id, buffer);

      const fbb = PostFB.Post.getRootAsPost(new ByteBuffer(buffer));

      return new PostNode<TActor>(
        this.db,
        fbb,
        this.authContext,
      );
    }

    *[Symbol.iterator](): Generator<PostNode<TActor>> {
      for (const [id, buffer] of this.db.scan(this.collectionName)) {
        const fbb = PostFB.Post.getRootAsPost(new ByteBuffer(buffer));
        yield new PostNode<TActor>(
          this.db,
          fbb,
          this.authContext,
        );
      }
    }
  }

export class ZgClient<TActor> extends ZgDatabase {
  public readonly users: UserCollection<TActor>;
  public readonly posts: PostCollection<TActor>;
  constructor(
    prollyTree: ProllyTree,
    config: ZgConfig<TActor> = { entityResolvers: {}, globalResolvers: {} },
    authContext: ZgAuthContext<TActor> | null = null,
  ) {
    super(prollyTree, config, authContext);
    this.users = new UserCollection<TActor>(this, this.authContext);
    this.posts = new PostCollection<TActor>(this, this.authContext);
  }

  public with<TActor>(actor: TActor): ZgClient<TActor> {
    return new ZgClient<TActor>(this.prollyTree, this.config, { actor });
  }
}"
`;
