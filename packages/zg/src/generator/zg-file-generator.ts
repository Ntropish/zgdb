import {
  NormalizedSchema,
  Field,
  Relationship,
  ManyToManyRelationship,
} from "../parser/types.js";
import { topologicalSort } from "./topological-sort.js";

function generateTsField(field: Field): string {
  // This needs to map FBS types to TS types
  const typeMap: Record<string, string> = {
    string: "string",
    long: "number",
    bool: "boolean",
  };

  // Handle table types, e.g., User_Profile -> Promise<ZGUserProfile>
  const isTableType = !typeMap[field.type] && !field.type.startsWith("[");
  const isTableArrayType = field.type.startsWith("[");

  let tsType = "any";
  if (typeMap[field.type]) {
    tsType = typeMap[field.type];
  } else if (isTableType) {
    tsType = `Promise<ZG${field.type} | null>`;
  } else if (isTableArrayType) {
    const baseType = field.type.replace(/\[|\]/g, "");
    tsType = `Promise<ZG${baseType}[] | null>`;
  }

  return `  ${field.name}: ${tsType};`;
}

function generateTsInterface(schema: NormalizedSchema): string {
  const fields = schema.fields.map(generateTsField).join("\n");

  const rels = schema.relationships
    .map((rel) => {
      const nodeType = `ZG${rel.node}`;
      const type =
        rel.cardinality === "one"
          ? `Promise<${nodeType} | null>`
          : `Promise<${nodeType}[]>`;
      return `  ${rel.name}: ${type};`;
    })
    .join("\n");

  const m2mRels = schema.manyToMany
    .map((rel) => {
      const nodeType = `ZG${rel.node}`;
      return `  ${rel.name}: Promise<${nodeType}[]>;`;
    })
    .join("\n");

  const allFields = [fields, rels, m2mRels].filter(Boolean).join("\n\n");

  return `export interface ZG${schema.name} {\n${allFields}\n}`;
}

function generateMetaData(schema: NormalizedSchema): string {
  const rels = schema.relationships
    .map(
      (rel) =>
        `    ${rel.name}: { type: '${rel.cardinality}', node: '${rel.node}'${
          rel.mappedBy ? `, mappedBy: '${rel.mappedBy}'` : ""
        } },`
    )
    .join("\n");

  const m2mRels = schema.manyToMany
    .map(
      (rel) =>
        `    ${rel.name}: { type: 'many', node: '${rel.node}', through: '${rel.through}' },`
    )
    .join("\n");

  return `export const ${schema.name}Meta = {
  getRootAs: LowLevel.${schema.name}.getRootAs${schema.name},
  relationships: {
${rels}
  },
  manyToMany: {
${m2mRels}
  },
};`;
}

/**
 * Generates the content for the high-level schema.zg.ts file.
 * @param schemas An array of all normalized schemas.
 * @returns The content of the schema.zg.ts file as a string.
 */
export function generateZgFile(schemas: NormalizedSchema[]): string {
  const fileHeader = `// Generated by ZG. Do not edit.\n\n`;
  const imports = `import { ZGDatabase, ZGNode } from '@tsmk/zg-client';\nimport * as LowLevel from './schema_generated';\n\n`;

  // Sort schemas to ensure consistent output order
  const sortedSchemas = topologicalSort(schemas);

  const interfaces = sortedSchemas.map(generateTsInterface).join("\n\n");
  const metadata = sortedSchemas.map(generateMetaData).join("\n\n");

  const schemaManifest = `export const schema = {\n${sortedSchemas
    .map((s) => `  ${s.name}: ${s.name}Meta,`)
    .join("\n")}\n};`;

  const dbInterfaceEntries = sortedSchemas
    .map((s) => `  ${s.name}: ZG${s.name};`)
    .join("\n");
  const createDbFn = `\nexport function createDatabase(config: any): ZGDatabase<{\n${dbInterfaceEntries}\n}> {\n  return new ZGDatabase(schema, config);\n}`;

  return (
    fileHeader +
    imports +
    interfaces +
    "\n\n" +
    metadata +
    "\n\n" +
    schemaManifest +
    "\n" +
    createDbFn +
    "\n"
  );
}
