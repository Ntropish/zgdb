import { NormalizedSchema } from "../parser/types.js";
import { topologicalSort } from "./topological-sort.js";
import { execSync } from "child_process";
import { GeneratorConfig } from "./types.js";

const asArray = <T>(value: T | T[]): T[] => {
  return Array.isArray(value) ? value : [value];
};

function mapTsType(fbsType: string): string {
  const typeMap: Record<string, string> = {
    string: "string",
    long: "bigint",
    bool: "boolean",
  };
  return typeMap[fbsType] || "any"; // Default for nested tables etc.
}

function generateInterface(schema: NormalizedSchema): string {
  const fields = schema.fields
    .map((f) => `  ${f.name}: ${mapTsType(f.type)};`)
    .join("\n");

  // TODO: Add relationships to interface
  return `export interface I${schema.name} {\n${fields}\n}`;
}

function generateNodeClass(schema: NormalizedSchema): string {
  const fields = schema.fields
    .map((f) => {
      let tsType = mapTsType(f.type);
      // Flatbuffers returns null for string fields that are not set.
      if (f.type === "string") {
        tsType = "string | null";
      }
      return `  get ${f.name}(): ${tsType} {
    return this.fbb.${f.name}();
  }`;
    })
    .join("\n\n");

  // TODO: Add relationship accessors

  return `export class ${schema.name}Node<TActor> extends ZgBaseNode<LowLevel.${schema.name}, TActor> {
  constructor(
    db: ZgDatabase,
    fbb: LowLevel.${schema.name},
    authContext: ZgAuthContext<TActor> | null
  ) {
    super(db, fbb, authContext);
  }

  // --- Fields ---
${fields}

  // --- Relationships ---
  // (to be implemented)
}`;
}

function generateDbAccessors(schema: NormalizedSchema): string {
  const schemaNameLower =
    schema.name.charAt(0).toLowerCase() + schema.name.slice(1);

  return `
  get ${schemaNameLower}s() {
    return {
      get: async (id: string): Promise<${schema.name}Node<TActor> | null> => {
        return this.db.get<LowLevel.${schema.name}, ${schema.name}Node<TActor>>('${schema.name}', id, (db, fbb, ac) => new ${schema.name}Node(db, fbb, ac));
      },
      create: async (data: Partial<I${schema.name}>): Promise<${schema.name}Node<TActor>> => {
        return this.db.create<LowLevel.${schema.name}, ${schema.name}Node<TActor>>('${schema.name}', data, (db, fbb, ac) => new ${schema.name}Node(db, fbb, ac));
      },
      update: async (id: string, data: Partial<I${schema.name}>): Promise<${schema.name}Node<TActor>> => {
        return this.db.update<LowLevel.${schema.name}, ${schema.name}Node<TActor>>('${schema.name}', id, data, (db, fbb, ac) => new ${schema.name}Node(db, fbb, ac));
      },
      delete: async (id: string): Promise<void> => {
        return this.db.delete('${schema.name}', id);
      }
    };
  }`;
}

export function generateZgFile(
  schemas: NormalizedSchema[],
  options: GeneratorConfig["options"] = {}
): string {
  const sortedSchemas = topologicalSort(schemas);

  const interfaces = sortedSchemas.map(generateInterface).join("\n\n");
  const nodeClasses = sortedSchemas.map(generateNodeClass).join("\n\n");
  const dbAccessors = sortedSchemas.map(generateDbAccessors).join("\n");
  const importExt = options.importExtension ?? ".js";

  return `// Generated by ZG. Do not edit.
import { ZgDatabase, ZgBaseNode, ZgAuthContext } from '@zgdb/client';
import * as LowLevel from './schema${importExt}';

// --- Interfaces ---
${interfaces}

// --- Node Classes ---
${nodeClasses}

// --- Database Class ---
export class ZgClient<TActor> {
  private db: ZgDatabase;
  private authContext: ZgAuthContext<TActor> | null = null;

  constructor() {
    this.db = new ZgDatabase();
  }

  setAuthContext(context: ZgAuthContext<TActor>) {
    this.authContext = context;
  }
${dbAccessors}
}

export function createDB<TActor>(config: {
  globalResolvers: Record<string, Function>;
  entityResolvers: Record<string, Record<string, Function>>;
  auth: Record<string, any>;
}) {
  const client = new ZgClient<TActor>();
  // TODO: Attach runtime resolvers and auth config
  return client;
}
`;
}

export function generateZgFileFromFlatc(
  schemaFilePath: string,
  outputDir: string
): string {
  const flatcArgs = [
    "--ts",
    "--gen-mutable",
    "--gen-all",
    "-o",
    outputDir,
    schemaFilePath,
  ];

  try {
    execSync(`flatc ${flatcArgs.join(" ")}`);
  } catch (error) {
    console.error("Error generating ZG file from flatc:", error);
    throw error;
  }

  return generateZgFileFromDirectory(outputDir);
}

export function generateZgFileFromDirectory(outputDir: string): string {
  // Implementation of generateZgFileFromDirectory
  throw new Error("Method not implemented");
}
