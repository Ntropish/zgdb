// Generated by ZG. Do not edit. import { ZgDatabase, ZgBaseNode, ZgAuthContext
} from '@tsmk/zg-client'; // Assuming these types exist import * as flatbuffers
from 'flatbuffers'; import * as LowLevel from './schema_generated.js'; // ---
Interfaces --- <% schemas.forEach(function(schema) { %> export interface I<%=
schema.name %> { <% schema.fields.forEach(function(field) { %> <%= field.name
%>: <%= field.tsType %><% if (field.optional) { %> | null<% } %>; <% }); %> <%
if (schema.relationships) { schema.relationships.forEach(function(rel) { %> <%=
rel.name %>(): Promise<I<% ="rel.node" %>
  | null>; <% }); } %> <% if (schema.manyToMany) {
  schema.manyToMany.forEach(function(m2m) { %> <%= m2m.name %>(): Promise<I<%
    ="m2m.node"
    %
    >[]>; <% }); } %> } <% }); %> // --- Node Classes --- <%
    schemas.forEach(function(schema) { %> export class <%= schema.name %>Node
    extends ZgBaseNode<LowLevel.<% ="schema.name" %
      >> implements I<%= schema.name %> { constructor(db: ZgDatabase, fbb:
      LowLevel.<%= schema.name %>, authContext: ZgAuthContext) { super(db, fbb,
      authContext); } // --- Fields --- <% schema.fields.forEach(function(field)
      { %> get <%= field.name %>(): <%= field.tsType %><% if (field.optional) {
      %> | null<% } %> { const value = this.fbb.<%= field.name %>(); return
      value; } <% }); %> // --- Relationships --- <% if (schema.relationships) {
      schema.relationships.forEach(function(rel) { %> async <%= rel.name %>():
      Promise<<%= rel.node %>Node | null> { const foreignKey = this.fbb.<%=
      rel.foreignKey %>(); if (!foreignKey) return null; return this.db.get('<%=
      rel.node %>', foreignKey, this.authContext); } <% }); } %> <% if
      (schema.manyToMany) { schema.manyToMany.forEach(function(m2m) { %> async
      <%= m2m.name %>(): Promise<<%= m2m.node %>Node[]> { return []; //
      Placeholder } <% }); } %> } <% }); %> // --- Database Class --- export
      class ZgClient { private db: ZgDatabase; private authContext:
      ZgAuthContext | null = null; constructor(config: any) { this.db = new
      ZgDatabase(config); } setAuthContext(context: ZgAuthContext) {
      this.authContext = context; } <% schemas.forEach(function(schema) { %> get
      <%= schema.name.charAt(0).toLowerCase() + schema.name.slice(1) %>s() {
      return { get: async (id: string): Promise<<%= schema.name %>Node | null>
      => { if (!this.authContext) throw new Error("Auth context not set");
      return this.db.get('<%= schema.name %>', id, this.authContext); }, create:
      async (data: Partial<I<% ="schema.name" %
        >>): Promise<<%= schema.name %>Node> => { if (!this.authContext) throw
        new Error("Auth context not set"); return this.db.create('<%=
        schema.name %>', data, this.authContext); }, update: async (id: string,
        data: Partial<I<% ="schema.name" %
          >>): Promise<<%= schema.name %>Node> => { if (!this.authContext) throw
          new Error("Auth context not set"); return this.db.update('<%=
          schema.name %>', id, data, this.authContext); }, delete: async (id:
          string): Promise<void>
            => { if (!this.authContext) throw new Error("Auth context not set");
            return this.db.delete('<%= schema.name %>', id, this.authContext); }
            }; } <% }); %> } export function createZgClient(config: any):
            ZgClient { return new ZgClient(config); }
          </void></I<%
        ></I<%
      ></LowLevel.<%
    ></I<%
  ></I<%
>
