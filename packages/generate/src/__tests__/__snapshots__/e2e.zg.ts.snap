// @generated
// Automatically generated. Don't change this file manually.
// Name: schema.ts


// @ts-nocheck
// This file is generated by @zgdb/zg. Do not edit it manually.
// TODO: Generate based on the user's config
import { ZgDatabase, ZgBaseNode, ZgAuthContext, EntityCollection } from '@zgdb/client';
import { Builder, ByteBuffer } from 'flatbuffers';
import * as TestEntityFB from './schema/test-entity.js';


// --- Interfaces ---
export interface ITestEntity {
  id: string;
  value: bigint;
}

// --- Create Input Types ---
export type CreateTestEntityInput = { value: bigint };

// --- Node Classes ---
export class TestEntityNode<TActor> extends ZgBaseNode<TestEntityFB.TestEntity, TActor> {
  constructor(
    db: ZgDatabase,
    fbb: TestEntityFB.TestEntity,
    authContext: ZgAuthContext<TActor> | null
  ) {
    super(db, fbb, authContext);
    
    return new Proxy(this, {
      get: (target, prop, receiver) => {
        const entityResolvers = target.db.config.entityResolvers?.['TestEntity'] ?? {};
        if (prop in entityResolvers) {
          return entityResolvers[prop as keyof typeof entityResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        const globalResolvers = target.db.config.globalResolvers ?? {};
        if (prop in globalResolvers) {
          return globalResolvers[prop as keyof typeof globalResolvers]({ actor: target.authContext?.actor, db: target.db, node: target });
        }
        return Reflect.get(target, prop, receiver);
      },
      set: (target, prop, value, receiver) => {
        const schemaFields = new Set(['id', 'value']);
        if (!schemaFields.has(prop as string)) {
          return Reflect.set(target, prop, value, receiver);
        }

        const builder = new Builder(1024);
        const data = { id: (prop === 'id') ? value : target.fbb.id(), value: (prop === 'value') ? value : target.fbb.value() };
        
    const idOffset = data.id ? builder.createString(data.id) : 0;
        
        const entityOffset = TestEntityFB.TestEntity.createTestEntity(builder, idOffset, data.value);
        builder.finish(entityOffset);
        const buffer = builder.asUint8Array();

        target.db.update(
          'TestEntity',
          target.id,
          buffer
        );
        
        const newFbb = TestEntityFB.TestEntity.getRootAsTestEntity(new ByteBuffer(buffer));
        target.fbb = newFbb;

        return true;
      }
    });
  }

  // --- Fields ---
  get id(): string | null {
    return this.fbb.id();
  }

  get value(): bigint {
    return this.fbb.value();
  }

  // --- Relationships ---

}

// --- Collection Classes ---
export class TestEntityCollection<TActor> {
    constructor(
      private db: ZgDatabase,
      private authContext: ZgAuthContext<TActor> | null
    ) {}

    get collectionName(): string {
      return 'TestEntity';
    }

    create(data: CreateTestEntityInput): TestEntityNode<TActor> {
      const builder = new Builder(1024);
      
          const idOffset = data.id ? builder.createString(data.id) : 0;
      

      TestEntityFB.TestEntity.startTestEntity(builder);
      
      TestEntityFB.TestEntity.addId(builder, idOffset ?? 0);
    TestEntityFB.TestEntity.addValue(builder, data.value ?? null);

      const entityOffset = TestEntityFB.TestEntity.endTestEntity(builder);
      
      builder.finish(entityOffset);
      const buffer = builder.asUint8Array();

      this.db.insert(this.collectionName, data.id, buffer);

      const fbb = TestEntityFB.TestEntity.getRootAsTestEntity(new ByteBuffer(buffer));

      return new TestEntityNode<TActor>(
        this.db,
        fbb,
        this.authContext,
      );
    }

    *[Symbol.iterator](): Generator<TestEntityNode<TActor>> {
      for (const [id, buffer] of this.db.scan(this.collectionName)) {
        const fbb = TestEntityFB.TestEntity.getRootAsTestEntity(new ByteBuffer(buffer));
        yield new TestEntityNode<TActor>(
          this.db,
          fbb,
          this.authContext,
        );
      }
    }
  }

export class ZgClient<TActor> extends ZgDatabase {
  public readonly testEntitys: TestEntityCollection<TActor>;
  constructor(
    prollyTree: ProllyTree,
    config: ZgConfig<TActor> = { entityResolvers: {}, globalResolvers: {} },
    authContext: ZgAuthContext<TActor> | null = null,
  ) {
    super(prollyTree, config, authContext);
    this.testEntitys = new TestEntityCollection<TActor>(this, this.authContext);
  }

  public with<TActor>(actor: TActor): ZgClient<TActor> {
    return new ZgClient<TActor>(this.prollyTree, this.config, { actor });
  }
}